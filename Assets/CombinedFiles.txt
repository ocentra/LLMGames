// File: CombineCSFilesEditor.cs

using System.IO;
using UnityEditor;
using UnityEngine;

public class CombineCSFilesEditor : EditorWindow
{
    private string startDirectory = "Assets";
    private string outputFile = "Assets/CombinedFiles.txt";

    [MenuItem("Tools/Combine CS Files")]
    public static void ShowWindow()
    {
        GetWindow<CombineCSFilesEditor>("Combine CS Files");
    }

    private void OnGUI()
    {
        GUILayout.Label("Combine .cs Files into a Single Document", EditorStyles.boldLabel);

        GUILayout.Label("Start Directory");
        if (GUILayout.Button("Select Start Directory"))
        {
            string selectedPath = EditorUtility.OpenFolderPanel("Select Start Directory", startDirectory, "");
            if (!string.IsNullOrEmpty(selectedPath))
            {
                startDirectory = selectedPath.Replace(Application.dataPath, "Assets");
            }
        }
        EditorGUILayout.TextField(startDirectory);

        GUILayout.Label("Output File");
        if (GUILayout.Button("Select Output File"))
        {
            string selectedPath = EditorUtility.SaveFilePanel("Select Output File", "", "CombinedFiles", "txt");
            if (!string.IsNullOrEmpty(selectedPath))
            {
                outputFile = selectedPath.Replace(Application.dataPath, "Assets");
            }
        }
        EditorGUILayout.TextField(outputFile);

        if (GUILayout.Button("Combine Files"))
        {
            CombineFiles();
        }
    }

    private void CombineFiles()
    {
        try
        {
            // Recursively get all .cs files
            var csFiles = Directory.GetFiles(startDirectory, "*.cs", SearchOption.AllDirectories);

            using (StreamWriter writer = new StreamWriter(outputFile))
            {
                foreach (var file in csFiles)
                {
                    writer.WriteLine($"// File: {Path.GetFileName(file)}\n");
                    writer.WriteLine(File.ReadAllText(file));
                    writer.WriteLine("\n// ---\n"); // Separator between files
                }
            }

            AssetDatabase.Refresh();
            EditorUtility.DisplayDialog("Success", $"All .cs files have been combined into {outputFile}", "OK");
        }
        catch (System.Exception ex)
        {
            EditorUtility.DisplayDialog("Error", $"An error occurred: {ex.Message}", "OK");
        }
    }
}


// ---

// File: SerializedNetworkBehaviour.cs

//-----------------------------------------------------------------------
// <copyright file="SerializedNetworkBehaviour.cs" company="Sirenix IVS">
// Copyright (c) Sirenix IVS. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

#if !UNITY_2019_1_OR_NEWER
#pragma warning disable 0618

namespace Sirenix.OdinInspector
{
    using Sirenix.Serialization;
    using UnityEngine;
    using UnityEngine.Networking;

    /// <summary>
    /// A Unity NetworkBehaviour which is serialized by the Sirenix serialization system.
    /// Please note that Odin's custom serialization only works for non-synced variables - [SyncVar] and SyncLists still have the same limitations.
    /// </summary>
    [ShowOdinSerializedPropertiesInInspector]
    public abstract class SerializedNetworkBehaviour : NetworkBehaviour, ISerializationCallbackReceiver, ISupportsPrefabSerialization
    {
        [SerializeField, HideInInspector]
        private SerializationData serializationData;

        SerializationData ISupportsPrefabSerialization.SerializationData { get { return this.serializationData; } set { this.serializationData = value; } }

        void ISerializationCallbackReceiver.OnAfterDeserialize()
        {
            UnitySerializationUtility.DeserializeUnityObject(this, ref this.serializationData);
            this.OnAfterDeserialize();
        }

        void ISerializationCallbackReceiver.OnBeforeSerialize()
        {
            UnitySerializationUtility.SerializeUnityObject(this, ref this.serializationData);
            this.OnBeforeSerialize();
        }

        /// <summary>
        /// Invoked after deserialization has taken place.
        /// </summary>
        protected virtual void OnAfterDeserialize()
        {
        }

        /// <summary>
        /// Invoked before serialization has taken place.
        /// </summary>
        protected virtual void OnBeforeSerialize()
        {
        }

#if UNITY_EDITOR

        [HideInTables]
        [OnInspectorGUI, PropertyOrder(int.MinValue)]
        private void InternalOnInspectorGUI()
        {
            EditorOnlyModeConfigUtility.InternalOnInspectorGUI(this);
        }

#endif
    }
}

#endif // UNITY_2019_1_OR_NEWER

// ---

// File: VectorIntFormatters.cs

#if UNITY_2017_2_OR_NEWER

//-----------------------------------------------------------------------
// <copyright file="VectorIntFormatters.cs" company="Sirenix IVS">
// Copyright (c) Sirenix IVS. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

[assembly: Sirenix.Serialization.RegisterFormatter(typeof(Sirenix.Serialization.Vector2IntFormatter))]
[assembly: Sirenix.Serialization.RegisterFormatter(typeof(Sirenix.Serialization.Vector3IntFormatter))]
namespace Sirenix.Serialization
{
    using UnityEngine;

    /// <summary>
    /// Custom formatter for the <see cref="Vector2Int"/> type.
    /// </summary>
    /// <seealso cref="Sirenix.Serialization.MinimalBaseFormatter{UnityEngine.Vector2Int}" />
    public class Vector2IntFormatter : MinimalBaseFormatter<Vector2Int>
    {
        private static readonly Serializer<int> Serializer = Serialization.Serializer.Get<int>();

        /// <summary>
        /// Reads into the specified value using the specified reader.
        /// </summary>
        /// <param name="value">The value to read into.</param>
        /// <param name="reader">The reader to use.</param>
        protected override void Read(ref Vector2Int value, IDataReader reader)
        {
            value.x = Vector2IntFormatter.Serializer.ReadValue(reader);
            value.y = Vector2IntFormatter.Serializer.ReadValue(reader);
        }

        /// <summary>
        /// Writes from the specified value using the specified writer.
        /// </summary>
        /// <param name="value">The value to write from.</param>
        /// <param name="writer">The writer to use.</param>
        protected override void Write(ref Vector2Int value, IDataWriter writer)
        {
            Vector2IntFormatter.Serializer.WriteValue(value.x, writer);
            Vector2IntFormatter.Serializer.WriteValue(value.y, writer);
        }
    }

    /// <summary>
    /// Custom formatter for the <see cref="Vector3Int"/> type.
    /// </summary>
    /// <seealso cref="Sirenix.Serialization.MinimalBaseFormatter{UnityEngine.Vector3Int}" />
    public class Vector3IntFormatter : MinimalBaseFormatter<Vector3Int>
    {
        private static readonly Serializer<int> Serializer = Serialization.Serializer.Get<int>();

        /// <summary>
        /// Reads into the specified value using the specified reader.
        /// </summary>
        /// <param name="value">The value to read into.</param>
        /// <param name="reader">The reader to use.</param>
        protected override void Read(ref Vector3Int value, IDataReader reader)
        {
            value.x = Vector3IntFormatter.Serializer.ReadValue(reader);
            value.y = Vector3IntFormatter.Serializer.ReadValue(reader);
            value.z = Vector3IntFormatter.Serializer.ReadValue(reader);
        }

        /// <summary>
        /// Writes from the specified value using the specified writer.
        /// </summary>
        /// <param name="value">The value to write from.</param>
        /// <param name="writer">The writer to use.</param>
        protected override void Write(ref Vector3Int value, IDataWriter writer)
        {
            Vector3IntFormatter.Serializer.WriteValue(value.x, writer);
            Vector3IntFormatter.Serializer.WriteValue(value.y, writer);
            Vector3IntFormatter.Serializer.WriteValue(value.z, writer);
        }
    }
}

#endif

// ---

// File: EnsureCorrectOdinVersion.cs

//-----------------------------------------------------------------------
// <copyright file="EnsureCorrectOdinVersion.cs" company="Sirenix ApS">
// Copyright (c) Sirenix ApS. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
#if UNITY_EDITOR

namespace Sirenix.OdinValidator.Editor
{
    using System;
    using System.IO;
    using System.Reflection;
    using UnityEditor;
    using UnityEngine;

    internal static class EnsureCorrectOdinVersion
    {
        private const string validatorVersion = "3.2.1.1";

        private static bool IsHeadlessOrBatchMode { get { return SystemInfo.graphicsDeviceType == UnityEngine.Rendering.GraphicsDeviceType.Null || UnityEditorInternal.InternalEditorUtility.inBatchMode; } }

        [InitializeOnLoadMethod]
        private static void Init()
        {
#if SIRENIX_INTERNAL
            return;
#endif

            if (EditorPrefs.HasKey("PREVENT_SIRENIX_FILE_GENERATION"))
                return;

            if (IsHeadlessOrBatchMode)
                return;

            if (TryGetOdinInspectorVersion(out var inspectorVersion))
            {
                var iVer = Version.Parse(inspectorVersion);
                var vVer = Version.Parse(validatorVersion);

                if (iVer.Major == vVer.Major && iVer.Minor == vVer.Minor && iVer.Build == vVer.Build) // Ignore Revision
                {
                    TryInstall();
                }
                else
                {
                    var latestVersion = iVer > vVer ? inspectorVersion : validatorVersion;
                    var oldestProduct = iVer > vVer ? "Odin Validator" : "Odin Inspector";
                    var misMatchText = inspectorVersion + " : " + validatorVersion;

                    if (TryGetOdinInstallPath(out var path))
                    {
                        var versionMismatchFile = path + "Odin Validator/ignoreVersionMismatch.txt";

                        if (File.Exists(versionMismatchFile))
                        {
                            var misMatch = File.ReadAllText(versionMismatchFile).Trim();
                            if (misMatch == misMatchText)
                                return;
                        }
                    }

                    if (!EditorUtility.DisplayDialog(
                        "Odin Version Mismatch",

                        "Odin Inspector and Odin Validator need to be on the same version to function correctly.\n" +
                        $"\n" +
                        $"Current Odin Inspector: {inspectorVersion}\n" +
                        $"Current Odin Validator: {validatorVersion}\n" +
                        $"\n" +
                        $"Please install {oldestProduct} {latestVersion}",

                        "OK", "Ignore until next version mismatch"))
                    {
                        var versionMismatchFile = path + "Odin Validator/ignoreVersionMismatch.txt";
                        File.WriteAllText(versionMismatchFile, misMatchText);
                    };
                }
            }
            else
            {
                EditorUtility.DisplayDialog(
                      "Odin Validator requires Odin Inspector",
                     $"Please install Odin Inspector {validatorVersion}",

                      "OK");
            }
        }

        private static void TryInstall()
        {
            if (TryGetOdinInstallPath(out var path))
            {
                var tmp_extension = "_tmp";
                var assemblyFiles = new string[]
                {
                    path + "Assemblies/Sirenix.OdinValidator.Editor.dll",
                    path + "Assemblies/Sirenix.OdinValidator.Editor.dll.meta",
                    path + "Assemblies/Sirenix.OdinValidator.Editor.xml",
                    path + "Assemblies/Sirenix.OdinValidator.Editor.xml.meta",
                    path + "Assemblies/Sirenix.OdinValidator.Editor.pdb",
                    path + "Assemblies/Sirenix.OdinValidator.Editor.pdb.meta",
                };

                var requireUpdate = File.Exists(assemblyFiles[0] + tmp_extension);

                if (requireUpdate)
                {
                    // Install / update Odin Validator.
                    AssetDatabase.StartAssetEditing();

                    foreach (var item in assemblyFiles)
                    {
                        var oldFile = item;
                        var newFile = item + tmp_extension;

                        if (File.Exists(newFile))
                        {
                            if (File.Exists(oldFile))
                                File.Delete(oldFile);

                            File.Move(newFile, oldFile);
                        }
                    }

                    AssetDatabase.StopAssetEditing();
                    AssetDatabase.Refresh(ImportAssetOptions.ForceUpdate);
                    EditorPrefs.SetBool("ODIN_VALIDATOR_SHOW_GETTING_STARTED", true);
                }
#if ODIN_INSPECTOR
                else if (EditorPrefs.GetBool("ODIN_VALIDATOR_SHOW_GETTING_STARTED", false))
                {
                    EditorPrefs.SetBool("ODIN_VALIDATOR_SHOW_GETTING_STARTED", false);
                    EditorApplication.delayCall += () =>
                    {
                        var t = Sirenix.Serialization.TwoWaySerializationBinder.Default.BindToType("Sirenix.OdinInspector.Editor.GettingStarted.GettingStartedWindow");
                        if (t != null)
                        {
                            var action = Utilities.Editor.Expressions.ExpressionUtility.ParseAction<bool, bool>("ShowWindow(false, true)", true, t, out var _);
                            action.Invoke(false, true);
                        }
                    };
                }
#endif
            }
            else
            {
                Debug.LogError("Odin Validator was unable to find Sirenix.Utilities.SirenixAssetPaths.SirenixPluginPath");
            }
        }

        private static bool TryGetOdinInstallPath(out string path)
        {
            var t = Type.GetType("Sirenix.Utilities.SirenixAssetPaths, Sirenix.Utilities");

            if (t == null)
            {
                path = null;
                return false;
            }

            var v = t.GetField("SirenixPluginPath", BindingFlags.Public | BindingFlags.Static);
            if (v == null)
            {
                path = null;
                return false;
            }

            path = v.GetValue(null) as string;
            return true;
        }

        private static bool TryGetOdinInspectorVersion(out string version)
        {
            var t = Type.GetType("Sirenix.OdinInspector.Editor.OdinInspectorVersion, Sirenix.OdinInspector.Editor");

            if (t == null)
            {
                version = null;
                return false;
            }

            var v = t.GetProperty("Version", BindingFlags.Public | BindingFlags.Static);
            if (v == null)
            {
                version = null;
                return false;
            }

            version = v.GetValue(null) as string;
            return true;
        }
    }
}

#endif


// ---

// File: AssemblyImportSettingsAutomation.cs

//-----------------------------------------------------------------------
// <copyright file="AssemblyImportSettingsAutomation.cs" company="Sirenix IVS">
// Copyright (c) Sirenix IVS. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

#if UNITY_EDITOR && UNITY_5_6_OR_NEWER

namespace Sirenix.OdinInspector.Editor
{
    using System.IO;
    using System.Collections.Generic;
    using Sirenix.Serialization.Utilities.Editor;
    using Sirenix.Utilities;
    using UnityEditor;
    using UnityEditor.Build;

#if UNITY_2018_1_OR_NEWER
    using UnityEditor.Build.Reporting;
#endif

    public class AssemblyImportSettingsAutomation :
#if UNITY_2018_1_OR_NEWER
        IPreprocessBuildWithReport
#else
        IPreprocessBuild
#endif
    {

        public int callbackOrder { get { return -1500; } }

        private static void ConfigureImportSettings()
        {
            if (EditorOnlyModeConfig.Instance.IsEditorOnlyModeEnabled() || ImportSettingsConfig.Instance.AutomateBeforeBuild == false)
            {
                return;
            }

            var assemblyDir = new DirectoryInfo(SirenixAssetPaths.SirenixAssembliesPath).FullName;
            var projectAssetsPath = Directory.GetCurrentDirectory().TrimEnd('\\', '/');

            var isPackage = PathUtilities.HasSubDirectory(new DirectoryInfo(projectAssetsPath), new DirectoryInfo(assemblyDir)) == false;

            var aotDirPath = assemblyDir + "NoEmitAndNoEditor/";
            var jitDirPath = assemblyDir + "NoEditor/";

            var aotDir = new DirectoryInfo(aotDirPath);
            var jitDir = new DirectoryInfo(jitDirPath);

            var aotAssemblies = new List<string>();
            var jitAssemblies = new List<string>();

            foreach (var file in aotDir.GetFiles("*.dll"))
            {
                string path = file.FullName;
                if (isPackage)
                {
                    path = SirenixAssetPaths.SirenixAssembliesPath.TrimEnd('\\', '/') + "/" + path.Substring(assemblyDir.Length);
                }
                else
                {
                    path = path.Substring(projectAssetsPath.Length + 1);
                }

                aotAssemblies.Add(path);
            }

            foreach (var file in jitDir.GetFiles("*.dll"))
            {
                string path = file.FullName;
                if (isPackage)
                {
                    path = SirenixAssetPaths.SirenixAssembliesPath.TrimEnd('\\', '/') + "/" + path.Substring(assemblyDir.Length);
                }
                else
                {
                    path = path.Substring(projectAssetsPath.Length + 1);
                }

                jitAssemblies.Add(path);
            }

            AssetDatabase.StartAssetEditing();
            try
            {
                var platform = EditorUserBuildSettings.activeBuildTarget;

                if (AssemblyImportSettingsUtilities.IsJITSupported(
                    platform,
                    AssemblyImportSettingsUtilities.GetCurrentScriptingBackend(),
                    AssemblyImportSettingsUtilities.GetCurrentApiCompatibilityLevel()))
                {
                    ApplyImportSettings(platform, aotAssemblies.ToArray(), OdinAssemblyImportSettings.ExcludeFromAll);
                    ApplyImportSettings(platform, jitAssemblies.ToArray(), OdinAssemblyImportSettings.IncludeInBuildOnly);
                }
                else
                {
                    ApplyImportSettings(platform, aotAssemblies.ToArray(), OdinAssemblyImportSettings.IncludeInBuildOnly);
                    ApplyImportSettings(platform, jitAssemblies.ToArray(), OdinAssemblyImportSettings.ExcludeFromAll);
                }
            }
            finally
            {
                AssetDatabase.StopAssetEditing();
            }
        }

        private static void ApplyImportSettings(BuildTarget platform, string[] assemblyPaths, OdinAssemblyImportSettings importSettings)
        {
            for (int i = 0; i < assemblyPaths.Length; i++)
            {
                AssemblyImportSettingsUtilities.SetAssemblyImportSettings(platform, assemblyPaths[i], importSettings);
            }
        }

#if UNITY_2018_1_OR_NEWER

        void IPreprocessBuildWithReport.OnPreprocessBuild(BuildReport report)
        {
            ConfigureImportSettings();
        }

#else

        void IPreprocessBuild.OnPreprocessBuild(BuildTarget target, string path)
        {
            ConfigureImportSettings();
        }

#endif
    }
}

#endif // UNITY_EDITOR && UNITY_5_6_OR_NEWER

// ---

// File: BuildAOTAutomation.cs

//-----------------------------------------------------------------------
// <copyright file="BuildAOTAutomation.cs" company="Sirenix IVS">
// Copyright (c) Sirenix IVS. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

#if UNITY_EDITOR && UNITY_5_6_OR_NEWER

namespace Sirenix.Serialization.Internal
{
    using Sirenix.Serialization;
    using UnityEditor;
    using UnityEditor.Build;
    using System.IO;
    using System;

#if UNITY_2018_1_OR_NEWER

    using UnityEditor.Build.Reporting;

#endif

#if UNITY_2018_1_OR_NEWER
    public class PreBuildAOTAutomation : IPreprocessBuildWithReport
#else
    public class PreBuildAOTAutomation : IPreprocessBuild
#endif
    {
        public int callbackOrder { get { return -1000; } }

        public void OnPreprocessBuild(BuildTarget target, string path)
        {
            if (AOTGenerationConfig.Instance.ShouldAutomationGeneration(target))
            {
                AOTGenerationConfig.Instance.ScanProject();
                AOTGenerationConfig.Instance.GenerateDLL();
            }
        }

#if UNITY_2018_1_OR_NEWER

        public void OnPreprocessBuild(BuildReport report)
        {
            this.OnPreprocessBuild(report.summary.platform, report.summary.outputPath);
        }

#endif
    }

#if UNITY_2018_1_OR_NEWER
    public class PostBuildAOTAutomation : IPostprocessBuildWithReport
#else
    public class PostBuildAOTAutomation : IPostprocessBuild
#endif
    {
        public int callbackOrder { get { return -1000; } }

        public void OnPostprocessBuild(BuildTarget target, string path)
        {
            if (AOTGenerationConfig.Instance.DeleteDllAfterBuilds && AOTGenerationConfig.Instance.ShouldAutomationGeneration(target))
            {
                Directory.Delete(AOTGenerationConfig.Instance.AOTFolderPath, true);
                File.Delete(AOTGenerationConfig.Instance.AOTFolderPath.TrimEnd('/', '\\') + ".meta");
                AssetDatabase.Refresh();
            }
        }

#if UNITY_2018_1_OR_NEWER

        public void OnPostprocessBuild(BuildReport report)
        {
            this.OnPostprocessBuild(report.summary.platform, report.summary.outputPath);
        }

#endif
    }
}

#endif // UNITY_EDITOR && UNITY_5_6_OR_NEWER

// ---

// File: EnsureOdinInspectorDefine.cs

//-----------------------------------------------------------------------
// <copyright file="EnsureOdinInspectorDefine.cs" company="Sirenix IVS">
// Copyright (c) Sirenix IVS. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

#if UNITY_EDITOR

namespace Sirenix.Utilities
{
    using System;
    using System.Linq;
    using UnityEditor;

    /// <summary>
    /// Defines the ODIN_INSPECTOR symbol.
    /// </summary>
    internal static class EnsureOdinInspectorDefine
    {
        private static readonly string[] DEFINES = new string[] { "ODIN_INSPECTOR", "ODIN_INSPECTOR_3" };

        [InitializeOnLoadMethod]
        private static void EnsureScriptingDefineSymbol()
        {
            var currentTarget = EditorUserBuildSettings.selectedBuildTargetGroup;

            if (currentTarget == BuildTargetGroup.Unknown)
            {
                return;
            }

            var definesString = PlayerSettings.GetScriptingDefineSymbolsForGroup(currentTarget).Trim();
            var defines = definesString.Split(';');

            bool changed = false;

            foreach (var define in DEFINES)
            {
                if (defines.Contains(define) == false)
                {
                    if (definesString.EndsWith(";", StringComparison.InvariantCulture) == false)
                    {
                        definesString += ";";
                    }

                    definesString += define;
                    changed = true;
                }
            }

            if (changed)
            {
                PlayerSettings.SetScriptingDefineSymbolsForGroup(currentTarget, definesString);
            }
        }
    }

    //
    // If you have a project where only some users have Odin, and you want to utilize the ODIN_INSPECTOR 
    // define symbol. Then, in order to only define the symbol for those with Odin, you can delete this script, 
    // which prevent ODIN_INSPECTOR from being added to the Unity's player settings.
    // 
    // And instead automatically add the ODIN_INSPECTOR define to an mcs.rsp file if Odin exists using the script below.
    // You can then ignore the mcs.rsp file in source control.
    // 
    // Remember to manually remove the ODIN_INSPECTOR define symbol in player settings after removing this script.
    //
    //    static class AddOdinInspectorDefineIfOdinExist
    //    {
    //        private const string ODIN_MCS_DEFINE = "-define:ODIN_INSPECTOR";
    //
    //        [InitializeOnLoadMethod]
    //        private static void AddOrRemoveOdinDefine()
    //        {
    //            var addDefine = AppDomain.CurrentDomain.GetAssemblies().Any(x => x.FullName.StartsWith("Sirenix.OdinInspector.Editor"));
    //
    // #if ODIN_INSPECTOR
    //            var hasDefine = true;
    // #else
    //            var hasDefine = false;
    // #endif
    //
    //            if (addDefine == hasDefine)
    //            {
    //                return;
    //            }
    //
    //            var mcsPath = Path.Combine(Application.dataPath, "mcs.rsp");
    //            var hasMcsFile = File.Exists(mcsPath);
    //
    //            if (addDefine)
    //            {
    //                var lines = hasMcsFile ? File.ReadAllLines(mcsPath).ToList() : new List<string>();
    //                if (!lines.Any(x => x.Trim() == ODIN_MCS_DEFINE))
    //                {
    //                    lines.Add(ODIN_MCS_DEFINE);
    //                    File.WriteAllLines(mcsPath, lines.ToArray());
    //                    AssetDatabase.Refresh();
    //                }
    //            }
    //            else if (hasMcsFile)
    //            {
    //                var linesWithoutOdinDefine = File.ReadAllLines(mcsPath).Where(x => x.Trim() != ODIN_MCS_DEFINE).ToArray();
    //
    //                if (linesWithoutOdinDefine.Length == 0)
    //                {
    //                    // Optional - Remove the mcs file instead if it doesn't contain any lines.
    //                    File.Delete(mcsPath);
    //                }
    //                else
    //                {
    //                    File.WriteAllLines(mcsPath, linesWithoutOdinDefine);
    //                }
    //
    //                AssetDatabase.Refresh();
    //            }
    //        }
    //    }
}

#endif // UNITY_EDITOR

// ---

// File: FixBrokenUnityObjectWrapperDrawer.cs

//-----------------------------------------------------------------------
// <copyright file="FixBrokenUnityObjectWrapperDrawer.cs" company="Sirenix IVS">
// Copyright (c) Sirenix IVS. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

#if UNITY_EDITOR && UNITY_2018_3_OR_NEWER
#pragma warning disable

namespace Sirenix.OdinInspector.Editor.Drawers
{
    using Sirenix.OdinInspector;
    using Sirenix.OdinInspector.Editor;
    using Sirenix.Utilities;
    using Sirenix.Utilities.Editor;
    using System.Linq;
    using UnityEditor;
    using UnityEngine;

    [DrawerPriority(0.001, 0, 0)]
    public class FixBrokenUnityObjectWrapperDrawer<T> : OdinValueDrawer<T>, IDefinesGenericMenuItems
        where T : UnityEngine.Component
    {
        private const string AUTO_FIX_PREFS_KEY = "TemporarilyBrokenUnityObjectWrapperDrawer.autoFix";

        private bool isBroken = false;
        private T realWrapperInstance;
        private bool allowSceneViewObjects;
        private static bool autoFix;

        protected override void Initialize()
        {
            this.allowSceneViewObjects = this.ValueEntry.Property.GetAttribute<AssetsOnlyAttribute>() == null;
            autoFix = EditorPrefs.HasKey(AUTO_FIX_PREFS_KEY);
        }

        protected override void DrawPropertyLayout(GUIContent label)
        {
            if (!(this.ValueEntry.ValueState == PropertyValueState.NullReference || this.ValueEntry.ValueState == PropertyValueState.ReferenceValueConflict))
            {
                this.CallNextDrawer(label);
                return;
            }

            if (Event.current.type == EventType.Layout)
            {
                this.isBroken = false;
                var count = this.ValueEntry.ValueCount;
                for (int i = 0; i < count; i++)
                {
                    var component = this.ValueEntry.Values[i];

                    if (ComponentIsBroken(component, ref this.realWrapperInstance))
                    {
                        this.isBroken = true;
                        break;
                    }
                }

                if (this.isBroken && autoFix)
                {
                    this.isBroken = false;

                    for (int i = 0; i < this.ValueEntry.ValueCount; i++)
                    {
                        T fixedComponent = null;
                        if (ComponentIsBroken(this.ValueEntry.Values[i], ref fixedComponent) && fixedComponent)
                        {
                            (this.ValueEntry as IValueEntryActualValueSetter<T>).SetActualValue(i, fixedComponent);
                        }
                    }

                    this.ValueEntry.Update();
                }
            }

            if (!this.isBroken)
            {
                this.CallNextDrawer(label);
                return;
            }

            var rect = EditorGUILayout.GetControlRect(label != null);
            var btnRect = rect.AlignRight(20);
            var controlRect = rect.SetXMax(btnRect.xMin - 5);

            object newInstance = null;

            EditorGUI.BeginChangeCheck();
            {
                if (this.ValueEntry.BaseValueType.IsInterface)
                {
                    newInstance = SirenixEditorFields.PolymorphicObjectField(controlRect,
                        label,
                        this.realWrapperInstance,
                        this.ValueEntry.BaseValueType,
                        this.allowSceneViewObjects);
                }
                else
                {
                    newInstance = SirenixEditorFields.UnityObjectField(
                        controlRect,
                        label,
                        this.realWrapperInstance,
                        this.ValueEntry.BaseValueType,
                        this.allowSceneViewObjects) as Component;
                }
            }
            if (EditorGUI.EndChangeCheck())
            {
                this.ValueEntry.WeakSmartValue = newInstance;
            }

            if (GUI.Button(btnRect, " ", EditorStyles.miniButton))
            {
                var popup = new FixBrokenUnityObjectWrapperPopup(this.ValueEntry);
                OdinEditorWindow.InspectObjectInDropDown(popup, 300);
            }

            if (Event.current.type == EventType.Repaint)
            {
                GUI.DrawTexture(btnRect, EditorIcons.ConsoleWarnicon, ScaleMode.ScaleToFit);
            }
        }

        private static bool ComponentIsBroken(T component, ref T realInstance)
        {
            var uObj = component;
            var oObj = (object)uObj;

            if (oObj != null && uObj == null)
            {
                var instanceId = uObj.GetInstanceID();
                if (AssetDatabase.Contains(instanceId))
                {
                    var path = AssetDatabase.GetAssetPath(instanceId);
                    var realWrapper = AssetDatabase.LoadAllAssetsAtPath(path).FirstOrDefault(n => n.GetInstanceID() == instanceId) as T;
                    if (realWrapper)
                    {
                        realInstance = realWrapper;
                        return true;
                    }
                }
            }

            return false;
        }

        public void PopulateGenericMenu(InspectorProperty property, GenericMenu genericMenu)
        {
            if (EditorPrefs.HasKey(AUTO_FIX_PREFS_KEY))
            {
                genericMenu.AddItem(new GUIContent("Disable auto-fix of broken prefab instance references"), false, (x) =>
                {
                    EditorPrefs.DeleteKey(AUTO_FIX_PREFS_KEY);
                    autoFix = false;
                }, null);
            }
        }

        [TypeInfoBox("This asset reference is temporarily broken until the next reload, because of an error in Unity where the C# wrapper object of a prefab asset is destroyed when changes are made to that prefab asset. This error has been reported to Unity.\n\nMeanwhile, Odin can fix this for you by getting a new, valid wrapper object from the asset database and replacing the broken wrapper instance with the new one.")]
        private class FixBrokenUnityObjectWrapperPopup
        {
            private IPropertyValueEntry<T> valueEntry;

            public FixBrokenUnityObjectWrapperPopup(IPropertyValueEntry<T> valueEntry)
            {
                this.valueEntry = valueEntry;
            }

            [HorizontalGroup, Button(ButtonSizes.Large)]
            public void FixItThisTime()
            {
                for (int i = 0; i < this.valueEntry.ValueCount; i++)
                {
                    var localI = i;
                    T fixedComponent = null;
                    if (ComponentIsBroken(this.valueEntry.Values[i], ref fixedComponent) && fixedComponent)
                    {
                        this.valueEntry.Property.Tree.DelayActionUntilRepaint(() =>
                        {
                            (this.valueEntry as IValueEntryActualValueSetter<T>).SetActualValue(localI, fixedComponent);
                        });
                    }
                }

                if (GUIHelper.CurrentWindow) 
                {
                    EditorApplication.delayCall += GUIHelper.CurrentWindow.Close;
                }
            }

            [HorizontalGroup, Button(ButtonSizes.Large)]
            public void FixItAlways()
            {
                EditorPrefs.SetBool(AUTO_FIX_PREFS_KEY, true);
                autoFix = true;

                if (GUIHelper.CurrentWindow) 
                {
                    EditorApplication.delayCall += GUIHelper.CurrentWindow.Close;
                }
            }
        }
    }
}

#endif

// ---

// File: SyncListDrawer.cs

//-----------------------------------------------------------------------
// <copyright file="SyncListDrawer.cs" company="Sirenix IVS">
// Copyright (c) Sirenix IVS. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

#if UNITY_EDITOR && !UNITY_2019_1_OR_NEWER
#pragma warning disable 0618

namespace Sirenix.OdinInspector.Editor.Drawers
{
    using Sirenix.Utilities.Editor;
    using UnityEditor;
    using UnityEngine;
    using UnityEngine.Networking;

    /// <summary>
    /// SyncList property drawer.
    /// </summary>
    [DrawerPriority(0, 0, 2)]
    public class SyncListDrawer<TList, TElement> : OdinValueDrawer<TList> where TList : SyncList<TElement>
    {
        private LocalPersistentContext<bool> visible;

        protected override void Initialize()
        {
            this.visible = this.Property.Context.GetPersistent(this, "expanded", GeneralDrawerConfig.Instance.OpenListsByDefault);
        }

        /// <summary>
        /// Draws the property.
        /// </summary>
        protected override void DrawPropertyLayout(GUIContent label)
        {
            var entry = this.ValueEntry;
            var property = entry.Property;
            int minCount = int.MaxValue;
            int maxCount = 0;

            for (int i = 0; i < entry.ValueCount; i++)
            {
                if (entry.Values[i].Count > maxCount)
                {
                    maxCount = entry.Values[i].Count;
                }

                if (entry.Values[i].Count < minCount)
                {
                    minCount = entry.Values[i].Count;
                }
            }

            SirenixEditorGUI.BeginHorizontalToolbar();
            this.visible.Value = SirenixEditorGUI.Foldout(this.visible.Value, GUIHelper.TempContent("SyncList " + label.text + "  [" + typeof(TList).Name + "]"));
            EditorGUILayout.LabelField(GUIHelper.TempContent(minCount == maxCount ? (minCount == 0 ? "Empty" : minCount + " items") : minCount + " (" + maxCount + ") items"), SirenixGUIStyles.RightAlignedGreyMiniLabel);
            SirenixEditorGUI.EndHorizontalToolbar();

            if (SirenixEditorGUI.BeginFadeGroup(this.visible, this.visible.Value))
            {
                GUIHelper.PushGUIEnabled(false);
                SirenixEditorGUI.BeginVerticalList();
                {
                    var elementLabel = new GUIContent();
                    for (int i = 0; i < maxCount; i++)
                    {
                        SirenixEditorGUI.BeginListItem();
                        elementLabel.text = "Item " + i;

                        if (i < minCount)
                        {
                            property.Children[i].Draw(elementLabel);
                        }
                        else
                        {
                            EditorGUILayout.LabelField(elementLabel, SirenixEditorGUI.MixedValueDashChar);
                        }
                        SirenixEditorGUI.EndListItem();
                    }
                }
                SirenixEditorGUI.EndVerticalList();
                GUIHelper.PopGUIEnabled();
            }
            SirenixEditorGUI.EndFadeGroup();
        }
    }
}

#endif // UNITY_EDITOR && !UNITY_2019_1_OR_NEWER

// ---

// File: SyncVarAttributeDrawer.cs

//-----------------------------------------------------------------------
// <copyright file="SyncVarAttributeDrawer.cs" company="Sirenix IVS">
// Copyright (c) Sirenix IVS. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

#if UNITY_EDITOR && !UNITY_2019_1_OR_NEWER
#pragma warning disable 0618

namespace Sirenix.OdinInspector.Editor.Drawers
{
    using Sirenix.Utilities;
    using UnityEditor;
    using UnityEngine;
    using UnityEngine.Networking;

    /// <summary>
    /// SyncVar attribute drawer.
    /// </summary>
    public class SyncVarAttributeDrawer : OdinAttributeDrawer<SyncVarAttribute>
    {
        /// <summary>
        /// Draws the property.
        /// </summary>
        protected override void DrawPropertyLayout(GUIContent label)
        {
            GUILayout.BeginHorizontal();
            {
                GUILayout.BeginVertical();
                {
                    this.CallNextDrawer(label);
                }
                GUILayout.EndVertical();

                GUILayout.Label("SyncVar", EditorStyles.miniLabel, GUILayoutOptions.Width(52f));
            }
            GUILayout.EndHorizontal();
        }
    }
}

#endif // UNITY_EDITOR && !UNITY_2019_1_OR_NEWER

// ---

// File: Vector2IntMinMaxAttributeDrawer.cs

//-----------------------------------------------------------------------
// <copyright file="Vector2IntMinMaxAttributeDrawer.cs" company="Sirenix IVS">
// Copyright (c) Sirenix IVS. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

#if UNITY_EDITOR && UNITY_2017_2_OR_NEWER

namespace Sirenix.OdinInspector.Editor.Drawers
{
    using Sirenix.OdinInspector;
    using Sirenix.OdinInspector.Editor;
    using Sirenix.OdinInspector.Editor.ValueResolvers;
    using Sirenix.Utilities;
    using Sirenix.Utilities.Editor;
    using System.Reflection;
    using UnityEditor;
    using UnityEngine;

    /// <summary>
    /// Draws Vector2Int properties marked with <see cref="MinMaxSliderAttribute"/>.
    /// </summary>
    public class Vector2IntMinMaxAttributeDrawer : OdinAttributeDrawer<MinMaxSliderAttribute, Vector2Int>
    {
        private ValueResolver<float> minGetter;
        private ValueResolver<float> maxGetter;
        private ValueResolver<Vector2Int> vector2IntMinMaxGetter;

        /// <summary>
        /// Initializes the drawer by resolving any optional references to members for min/max value.
        /// </summary>
        protected override void Initialize()
        {
            // Min member reference.
            this.minGetter = ValueResolver.Get<float>(this.Property, this.Attribute.MinValueGetter, this.Attribute.MinValue);
            this.maxGetter = ValueResolver.Get<float>(this.Property, this.Attribute.MaxValueGetter, this.Attribute.MaxValue);

            // Min max member reference.
            if (this.Attribute.MinMaxValueGetter != null)
            {
                this.vector2IntMinMaxGetter = ValueResolver.Get<Vector2Int>(this.Property, this.Attribute.MinMaxValueGetter);
            }
        }

        /// <summary>
        /// Draws the property.
        /// </summary>
        protected override void DrawPropertyLayout(GUIContent label)
        {
            ValueResolver.DrawErrors(this.minGetter, this.maxGetter, this.vector2IntMinMaxGetter);

            // Get the range of the slider from the attribute or from member references.
            Vector2 range;
            if (this.vector2IntMinMaxGetter != null && !this.vector2IntMinMaxGetter.HasError)
            {
                range = (Vector2)this.vector2IntMinMaxGetter.GetValue();
            }
            else
            {
                range.x = this.minGetter.GetValue();
                range.y = this.maxGetter.GetValue();
            }

            EditorGUI.BeginChangeCheck();
            Vector2 value = SirenixEditorFields.MinMaxSlider(label, (Vector2)this.ValueEntry.SmartValue, range, this.Attribute.ShowFields);
            if (EditorGUI.EndChangeCheck())
            {
                this.ValueEntry.SmartValue = new Vector2Int((int)value.x, (int)value.y);
            }
        }
    }
}
#endif // UNITY_EDITOR && UNITY_2017_2_OR_NEWER

// ---

// File: VectorIntDrawers.cs

//-----------------------------------------------------------------------
// <copyright file="VectorIntDrawers.cs" company="Sirenix IVS">
// Copyright (c) Sirenix IVS. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

#if UNITY_EDITOR && UNITY_2017_2_OR_NEWER

namespace Sirenix.OdinInspector.Editor.Drawers
{
    using Utilities.Editor;
    using UnityEditor;
    using UnityEngine;

    /// <summary>
    /// Vector2Int proprety drawer.
    /// </summary>
    public sealed class Vector2IntDrawer : OdinValueDrawer<Vector2Int>, IDefinesGenericMenuItems
    {
        /// <summary>
        /// Draws the property.
        /// </summary>
        protected override void DrawPropertyLayout(GUIContent label)
        {
            Rect labelRect;
            var contentRect = SirenixEditorGUI.BeginHorizontalPropertyLayout(label, out labelRect);
            {
                EditorGUI.BeginChangeCheck();
                var val = SirenixEditorFields.VectorPrefixSlideRect(labelRect, (Vector2)this.ValueEntry.SmartValue);
                if (EditorGUI.EndChangeCheck())
                {
                    this.ValueEntry.SmartValue = new Vector2Int((int)val.x, (int)val.y);
                }

                var showLabels = SirenixEditorFields.ResponsiveVectorComponentFields && contentRect.width >= 185;
                GUIHelper.PushLabelWidth(SirenixEditorFields.SingleLetterStructLabelWidth);
                this.ValueEntry.Property.Children[0].Draw(showLabels ? GUIHelper.TempContent("X") : null);
                this.ValueEntry.Property.Children[1].Draw(showLabels ? GUIHelper.TempContent("Y") : null);
                GUIHelper.PopLabelWidth();

            }
            SirenixEditorGUI.EndHorizontalPropertyLayout();
        }

        /// <summary>
        /// Populates the generic menu for the property.
        /// </summary>
        public void PopulateGenericMenu(InspectorProperty property, GenericMenu genericMenu)
        {
            Vector2Int value = (Vector2Int)property.ValueEntry.WeakSmartValue;

            if (genericMenu.GetItemCount() > 0)
            {
                genericMenu.AddSeparator("");
            }
            genericMenu.AddItem(new GUIContent("Zero", "Set the vector to (0, 0)"), value == Vector2Int.zero, () => SetVector(property, Vector2Int.zero));
            genericMenu.AddItem(new GUIContent("One", "Set the vector to (1, 1)"), value == Vector2Int.one, () => SetVector(property, Vector2Int.one));
            genericMenu.AddSeparator("");
            genericMenu.AddItem(new GUIContent("Right", "Set the vector to (1, 0)"), value == Vector2Int.right, () => SetVector(property, Vector2Int.right));
            genericMenu.AddItem(new GUIContent("Left", "Set the vector to (-1, 0)"), value == Vector2Int.left, () => SetVector(property, Vector2Int.left));
            genericMenu.AddItem(new GUIContent("Up", "Set the vector to (0, 1)"), value == Vector2Int.up, () => SetVector(property, Vector2Int.up));
            genericMenu.AddItem(new GUIContent("Down", "Set the vector to (0, -1)"), value == Vector2Int.down, () => SetVector(property, Vector2Int.down));
        }

        private void SetVector(InspectorProperty property, Vector2Int value)
        {
            property.Tree.DelayActionUntilRepaint(() =>
            {
                for (int i = 0; i < property.ValueEntry.ValueCount; i++)
                {
                    property.ValueEntry.WeakValues[i] = value;
                }
            });
        }
    }

    /// <summary>
    /// Vector3Int property drawer.
    /// </summary>
    public sealed class Vector3IntDrawer : OdinValueDrawer<Vector3Int>, IDefinesGenericMenuItems
    {
        /// <summary>
        /// Draws the property.
        /// </summary>
        protected override void DrawPropertyLayout(GUIContent label)
        {
            Rect labelRect;
            var contentRect = SirenixEditorGUI.BeginHorizontalPropertyLayout(label, out labelRect);
            {
                EditorGUI.BeginChangeCheck();
                var val = SirenixEditorFields.VectorPrefixSlideRect(labelRect, (Vector3)this.ValueEntry.SmartValue);
                if (EditorGUI.EndChangeCheck())
                {
                    this.ValueEntry.SmartValue = new Vector3Int((int)val.x, (int)val.y, (int)val.z);
                }

                var showLabels = SirenixEditorFields.ResponsiveVectorComponentFields && contentRect.width >= 185;
                GUIHelper.PushLabelWidth(SirenixEditorFields.SingleLetterStructLabelWidth);
                this.ValueEntry.Property.Children[0].Draw(showLabels ? GUIHelper.TempContent("X") : null);
                this.ValueEntry.Property.Children[1].Draw(showLabels ? GUIHelper.TempContent("Y") : null);
                this.ValueEntry.Property.Children[2].Draw(showLabels ? GUIHelper.TempContent("Z") : null);
                GUIHelper.PopLabelWidth();

            }
            SirenixEditorGUI.EndHorizontalPropertyLayout();
        }

        /// <summary>
        /// Populates the generic menu for the property.
        /// </summary>
        public void PopulateGenericMenu(InspectorProperty property, GenericMenu genericMenu)
        {
            Vector3Int value = (Vector3Int)property.ValueEntry.WeakSmartValue;

            if (genericMenu.GetItemCount() > 0)
            {
                genericMenu.AddSeparator("");
            }

            genericMenu.AddItem(new GUIContent("Zero", "Set the vector to (0, 0, 0)"), value == Vector3Int.zero, () => SetVector(property, Vector3Int.zero));
            genericMenu.AddItem(new GUIContent("One", "Set the vector to (1, 1, 1)"), value == Vector3Int.one, () => SetVector(property, Vector3Int.one));
            genericMenu.AddSeparator("");
            genericMenu.AddItem(new GUIContent("Right", "Set the vector to (1, 0, 0)"), value == Vector3Int.right, () => SetVector(property, Vector3Int.right));
            genericMenu.AddItem(new GUIContent("Left", "Set the vector to (-1, 0, 0)"), value == Vector3Int.left, () => SetVector(property, Vector3Int.left));
            genericMenu.AddItem(new GUIContent("Up", "Set the vector to (0, 1, 0)"), value == Vector3Int.up, () => SetVector(property, Vector3Int.up));
            genericMenu.AddItem(new GUIContent("Down", "Set the vector to (0, -1, 0)"), value == Vector3Int.down, () => SetVector(property, Vector3Int.down));
            genericMenu.AddItem(new GUIContent("Forward", "Set the vector property to (0, 0, 1)"), value == new Vector3Int(0, 0, 1), () => SetVector(property, new Vector3Int(0, 0, 1)));
            genericMenu.AddItem(new GUIContent("Back", "Set the vector property to (0, 0, -1)"), value == new Vector3Int(0, 0, -1), () => SetVector(property, new Vector3Int(0, 0, -1)));
        }

        private void SetVector(InspectorProperty property, Vector3Int value)
        {
            property.Tree.DelayActionUntilRepaint(() =>
            {
                property.ValueEntry.WeakSmartValue = value;
            });
        }
    }
}

#endif // UNITY_EDITOR && UNITY_2017_2_OR_NEWER

// ---

// File: VectorIntPropertyResolvers.cs

//-----------------------------------------------------------------------
// <copyright file="VectorIntPropertyResolvers.cs" company="Sirenix IVS">
// Copyright (c) Sirenix IVS. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

#if UNITY_EDITOR && UNITY_2017_2_OR_NEWER

namespace Sirenix.OdinInspector.Editor.Drawers
{
    using UnityEngine;

    public sealed class Vector2IntResolver : BaseMemberPropertyResolver<Vector2Int>
    {
        protected override InspectorPropertyInfo[] GetPropertyInfos()
        {
            return new InspectorPropertyInfo[]
            {
                InspectorPropertyInfo.CreateValue("x", 0, this.Property.ValueEntry.SerializationBackend,
                    new GetterSetter<Vector2Int, int>(
                        getter: (ref Vector2Int vec) => vec.x,
                        setter: (ref Vector2Int vec, int value) => vec.x = value)),
                InspectorPropertyInfo.CreateValue("y", 0, this.Property.ValueEntry.SerializationBackend,
                    new GetterSetter<Vector2Int, int>(
                        getter: (ref Vector2Int vec) => vec.y,
                        setter: (ref Vector2Int vec, int value) => vec.y = value)),
            };
        }
    }

    public sealed class Vector3IntResolver : BaseMemberPropertyResolver<Vector3Int>
    {
        protected override InspectorPropertyInfo[] GetPropertyInfos()
        {
            return new InspectorPropertyInfo[]
            {
                InspectorPropertyInfo.CreateValue("x", 0, this.Property.ValueEntry.SerializationBackend,
                    new GetterSetter<Vector3Int, int>(
                        getter: (ref Vector3Int vec) => vec.x,
                        setter: (ref Vector3Int vec, int value) => vec.x = value)),
                InspectorPropertyInfo.CreateValue("y", 0, this.Property.ValueEntry.SerializationBackend,
                    new GetterSetter<Vector3Int, int>(
                        getter: (ref Vector3Int vec) => vec.y,
                        setter: (ref Vector3Int vec, int value) => vec.y = value)),
                InspectorPropertyInfo.CreateValue("z", 0, this.Property.ValueEntry.SerializationBackend,
                    new GetterSetter<Vector3Int, int>(
                        getter: (ref Vector3Int vec) => vec.z,
                        setter: (ref Vector3Int vec, int value) => vec.z = value)),
            };
        }
    }
}

#endif // UNITY_EDITOR && UNITY_2017_2_OR_NEWER

// ---

// File: AuthenticationManager.cs

using Sirenix.OdinInspector;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using OcentraAI.LLMGames.Screens;
using Unity.Services.Authentication;
using Unity.Services.Authentication.PlayerAccounts;
using Unity.Services.Core;
using UnityEngine;

namespace OcentraAI.LLMGames.Authentication
{
    [RequireComponent(typeof(UnityServicesManager))]
    public class AuthenticationManager : MonoBehaviour
    {
        public static AuthenticationManager Instance { get; private set; }


        [ShowInInspector]
        public PlayerData PlayerData { get; private set; } = null;
        public bool IsSigningIn { get; private set; }
        public bool IsLoggedIn { get; set; }

        public string PlayerName { get; private set; }

        public event Action AuthenticationCompleted;

        public bool UseAnonymousSignIn  = false;

        async void Awake()
        {
            if (Instance != null && Instance != this)
            {
                Destroy(gameObject);
            }
            else
            {
                Instance = this;
                DontDestroyOnLoad(gameObject);
            }

            await UnityServices.InitializeAsync();
        }


        async void Start()
        {
            try
            {

                SetAuthenticationEvents();
            }
            catch (Exception e)
            {
                Debug.LogException(e);
            }

            if (LoginScreen.Instance !=null)
            {
                AuthenticationCompleted += LoginScreen.Instance.OnAuthenticationCompleted;

            }
            else
            {
                AuthenticationCompleted += OnAuthenticationCompleted;
            }
            
            PlayerAccountService.Instance.SignedIn += SignInWithUnityAsync;

            if (UseAnonymousSignIn)
            {
               await SignInAnonymouslyAsync();
            }
        }

        public void OnAuthenticationCompleted()
        {
            
           IsLoggedIn = true;
        }

        private void SetAuthenticationEvents()
        {
            AuthenticationService.Instance.SignedIn += async () =>
            {
                //Debug.Log($"PlayerID: {AuthenticationService.Instance.PlayerId}");
                //Debug.Log($"Access Token: {AuthenticationService.Instance.AccessToken}");

                (bool success, PlayerData playerData) = await GetOrCreatePlayerDataAndUpdate();

                if (success)
                {
                    PlayerData = playerData;

                    await UnityServicesManager.Instance.SavePlayerDataToCloud(PlayerData);

                    if (!string.IsNullOrEmpty(PlayerData.PlayerName))
                    {
                        await UpdatePlayerNameAsync(PlayerData.PlayerName);
                    }
                    else
                    {
                        if (LoginScreen.Instance != null)
                        {
                            LoginScreen.Instance.ShowErrorMessage("PlayerName is Null or empty");
                        }
                        else
                        {
                            Debug.LogError("PlayerName is Null or empty");
                        }
                    }
                }
                else
                {
                    if (LoginScreen.Instance != null)
                    {
                        LoginScreen.Instance.ShowErrorMessage("PlayerData could not be retrieved");
                    }
                    else
                    {
                        Debug.LogError("PlayerData could not be retrieved");
                    }
                }

                // Invoke the event for main thread to respond
                AuthenticationCompleted?.Invoke();
            };

            AuthenticationService.Instance.SignInFailed += (err) =>
            {
                IsLoggedIn = false;
                PlayerData = null;
                if (LoginScreen.Instance != null)
                {
                    LoginScreen.Instance.ShowErrorMessage($"{err.ErrorCode} \n {err.Message}");
                }
                else
                {
                    Debug.LogError($"{err.ErrorCode} \n {err.Message}");
                }
            };

            AuthenticationService.Instance.SignedOut += () =>
            {
                IsLoggedIn = false;
                PlayerData = null;
                if (LoginScreen.Instance != null)
                {
                    LoginScreen.Instance.ShowErrorMessage("Player signed out.");
                }
                else
                {
                    Debug.LogError("Player signed out.");
                }
            };

            AuthenticationService.Instance.Expired += () =>
            {
                IsLoggedIn = false;
                PlayerData = null;
                if (LoginScreen.Instance != null)
                {
                    LoginScreen.Instance.ShowErrorMessage("Player session could not be refreshed and expired.");
                }
                else
                {
                    Debug.LogError("Player session could not be refreshed and expired.");
                }
            };
        }

        public async Task PerformAuthenticationAsync(Func<string, string, Task> authOperation, string username, string password, Action<string> onError, int maxRetries = 2)
        {
            if (IsSigningIn) return;

            IsSigningIn = true;

            int retryCount = 0;
            while (retryCount <= maxRetries)
            {
                try
                {
                    await authOperation(username, password);
                    break;
                }
                catch (AuthenticationException ex)
                {
                    HandleAuthenticationException(ex, onError);
                    break;
                }
                catch (RequestFailedException ex) when (IsNetworkError(ex))
                {
                    if (CheckInternetConnection())
                    {
                        retryCount++;
                        continue;
                    }
                    onError($"Network error: {ex.Message}");
                    break;
                }
                catch (Exception ex)
                {
                    onError($"Error: {ex.Message}");
                    break;
                }
            }

            IsSigningIn = false;
        }

        public async Task StartSignInAsync(Action<string> onError)
        {
            try
            {
                await PlayerAccountService.Instance.StartSignInAsync();
            }
            catch (RequestFailedException ex)
            {
                Debug.LogException(ex);
                onError(ex.Message);
            }
        }

        public async Task StartSignInAsync()
        {
            if (PlayerAccountService.Instance.IsSignedIn)
            {
                SignInWithUnityAsync();
                return;
            }

            try
            {
                await PlayerAccountService.Instance.StartSignInAsync();
            }
            catch (RequestFailedException ex)
            {
                Debug.LogException(ex);

            }
        }

        private async void SignInWithUnityAsync()
        {
            if (IsSigningIn) return;

            IsSigningIn = true;
            if (LoginScreen.Instance != null)
            {
                LoginScreen.Instance.UpdateButtonInteractability(false);
            }

            try
            {
                await AuthenticationService.Instance.SignInWithUnityAsync(PlayerAccountService.Instance.AccessToken);
                Debug.Log("SignIn is successful.");
            }
            catch (AuthenticationException ex)
            {
                var message = $"SignInWithUnityAsync: AuthenticationException :  \n   {ex.ErrorCode} \n {ex.Message}";
                if (LoginScreen.Instance != null)
                {
                    LoginScreen.Instance.ShowErrorMessage(message);
                }
                else
                {
                    Debug.LogException(ex);
                }
            }
            catch (RequestFailedException ex)
            {
                var message = $"SignInWithUnityAsync: RequestFailedException :  \n  {ex.ErrorCode} \n {ex.Message}";
                if (LoginScreen.Instance != null)
                {
                    LoginScreen.Instance.ShowErrorMessage(message);
                }
                else
                {
                    Debug.LogException(ex);
                }
            }
            finally
            {
                IsSigningIn = false;
                if (LoginScreen.Instance != null)
                {
                    LoginScreen.Instance.UpdateButtonInteractability(true);
                }
            }
        }


        private async Task<bool> LinkWithUnityAsync()
        {
            try
            {
                await AuthenticationService.Instance.LinkWithUnityAsync(PlayerAccountService.Instance.AccessToken);
                Debug.Log("Link is successful.");
                return true;
            }
            catch (AuthenticationException ex) when (ex.ErrorCode == AuthenticationErrorCodes.AccountAlreadyLinked)
            {
                var message = $"LinkWithUnityAsync: AccountAlreadyLinked :  \n   {ex.ErrorCode} \n {ex.Message}";
                if (LoginScreen.Instance != null)
                {
                    LoginScreen.Instance.ShowErrorMessage(message);
                }
                else
                {
                    Debug.LogError("This user is already linked with another account. Log in instead.");
                }
                return false;
            }
            catch (AuthenticationException ex)
            {
                var message = $"LinkWithUnityAsync: AuthenticationException :  \n   {ex.ErrorCode} \n {ex.Message}";
                if (LoginScreen.Instance != null)
                {
                    LoginScreen.Instance.ShowErrorMessage(message);
                }
                else
                {
                    Debug.LogException(ex);
                }
                return false;
            }
            catch (RequestFailedException ex)
            {
                var message = $"LinkWithUnityAsync: RequestFailedException :  \n  {ex.ErrorCode} \n {ex.Message}";
                if (LoginScreen.Instance != null)
                {
                    LoginScreen.Instance.ShowErrorMessage(message);
                }
                else
                {
                    Debug.LogException(ex);
                }
                return false;
            }
        }


        private async Task SignInAnonymouslyAsync()
        {
            try
            {
                SignInOptions signInOptions = new SignInOptions
                {
                    CreateAccount = true
                };

                await AuthenticationService.Instance.SignInAnonymouslyAsync(signInOptions);
                //Debug.Log("Sign in anonymously succeeded!");
                //Debug.Log($"PlayerID: {AuthenticationService.Instance.PlayerId}");
            }
            catch (AuthenticationException ex)
            {
                var message = $"SignInAnonymouslyAsync: AuthenticationException :  \n    {ex.ErrorCode} \n {ex.Message}";
                if (LoginScreen.Instance != null)
                {
                    LoginScreen.Instance.ShowErrorMessage(message);
                }
                else
                {
                    Debug.LogException(ex);
                }
            }
            catch (RequestFailedException ex)
            {
                var message = $"SignInAnonymouslyAsync: RequestFailedException :  \n  {ex.ErrorCode} \n {ex.Message}";
                if (LoginScreen.Instance != null)
                {
                    LoginScreen.Instance.ShowErrorMessage(message);
                }
                else
                {
                    Debug.LogException(ex);
                }
            }
        }


        private async Task AddUsernamePasswordAsync(string username, string password)
        {
            try
            {
                await AuthenticationService.Instance.AddUsernamePasswordAsync(username, password);
                // Debug.Log("Username and password added.");
            }
            catch (AuthenticationException ex)
            {
                if (LoginScreen.Instance != null)
                {
                    LoginScreen.Instance.ShowErrorMessage($"AddUsernamePasswordAsync: AuthenticationException :  \n {ex.ErrorCode} \n {ex.Message}");

                }
                else
                {
                    Debug.LogException(ex);

                }
            }
            catch (RequestFailedException ex)
            {
                if (LoginScreen.Instance != null)
                {
                    LoginScreen.Instance.ShowErrorMessage($"AddUsernamePasswordAsync: RequestFailedException :  \n {ex.ErrorCode} \n {ex.Message}");

                }
                else
                {
                    Debug.LogException(ex);

                }

            }
        }

        private async Task<(bool success, PlayerData playerData)> GetOrCreatePlayerDataAndUpdate()
        {
            try
            {
                PlayerData data = default;

                (bool success, PlayerData playerData) = await UnityServicesManager.Instance.TryGetPlayerDataFromCloud(AuthenticationService.Instance.PlayerId);

                if (success)
                {
                    data = playerData;
                    data.PlayerID = AuthenticationService.Instance.PlayerId;
                    if (string.IsNullOrEmpty(data.PlayerName))
                    {
                        var (userName, email) = await LoginScreen.Instance.ShowUserNameAndEmailUI();
                        data.PlayerName = userName;
                    }
                }
                else
                {
                    string userName = "Guest";

                    data = new PlayerData
                    {
                        PlayerID = AuthenticationService.Instance.PlayerId,
                        PlayerName = userName,
                    };
                }

                PlayerName = data.PlayerName;

                return (true, data);
            }
            catch (Exception e)
            {
                Debug.LogError($" GetOrCreatePlayerDataAndUpdate {e}");
            }

            return (false, null);
        }

        private async Task SignInCachedUserAsync()
        {
            if (!AuthenticationService.Instance.SessionTokenExists)
            {
                return;
            }

            try
            {
                string accessToken = AuthenticationService.Instance.AccessToken;
                if (accessToken != null)
                {
                    if (!await LinkWithUnityAsync())
                    {
                        if (LoginScreen.Instance != null && LoginScreen.Instance.ValidateUserAndPassword())
                        {
                            await AddUsernamePasswordAsync(LoginScreen.Instance.UserNameInputField.text, LoginScreen.Instance.PasswordInputField.text);
                        }
                        else
                        {
                            SignInOptions signInOptions = new SignInOptions
                            {
                                CreateAccount = true
                            };

                            await AuthenticationService.Instance.SignInAnonymouslyAsync(signInOptions);
                            //Debug.Log("Sign in anonymously succeeded!");
                            //Debug.Log($"PlayerID: {AuthenticationService.Instance.PlayerId}");
                        }
                    }
                }
            }
            catch (AuthenticationException ex)
            {
                var message = $"SignInCachedUserAsync: AuthenticationException :  \n    {ex.ErrorCode} \n {ex.Message}";
                if (LoginScreen.Instance != null)
                {
                    LoginScreen.Instance.ShowErrorMessage(message);
                }
                else
                {
                    Debug.LogException(ex);
                }
            }
            catch (RequestFailedException ex)
            {
                var message = $"SignInCachedUserAsync: RequestFailedException :  \n {ex.ErrorCode} \n {ex.Message}";
                if (LoginScreen.Instance != null)
                {
                    LoginScreen.Instance.ShowErrorMessage(message);
                }
                else
                {
                    Debug.LogException(ex);
                }
            }
        }

        private bool IsNetworkError(RequestFailedException ex)
        {
            var networkErrorCodes = new HashSet<int>
            {
                401, // Unauthorized
                403, // Forbidden
                404, // Not Found
                408, // Request Timeout
                500, // Internal Server Error
                503, // Service Unavailable
                504  // Gateway Timeout
            };

            return networkErrorCodes.Contains(ex.ErrorCode);
        }

        private bool CheckInternetConnection()
        {
            return Application.internetReachability != NetworkReachability.NotReachable;
        }

        private void HandleAuthenticationException(AuthenticationException ex, Action<string> onError)
        {
            if (ex.ErrorCode == AuthenticationErrorCodes.ClientInvalidProfile)
            {
                onError("Account does not exist. Please create a new user.");
            }
            else if (ex.ErrorCode == AuthenticationErrorCodes.InvalidParameters)
            {
                onError("Invalid username or password.");
            }
            else
            {
                onError($"Authentication error: {ex.ErrorCode} \n {ex.Message}");
            }
        }

        private async Task UpdatePlayerNameAsync(string username)
        {
            try
            {
                await AuthenticationService.Instance.UpdatePlayerNameAsync(username);
                //Debug.Log("Username added.");
            }
            catch (AuthenticationException ex)
            {
                var message = $"UpdatePlayerNameAsync: AuthenticationException :  \n {ex.ErrorCode} \n {ex.Message}";
                if (LoginScreen.Instance != null)
                {
                    LoginScreen.Instance.ShowErrorMessage(message);
                }
                else
                {
                    Debug.LogException(ex);
                }
            }
            catch (RequestFailedException ex)
            {
                var message = $"UpdatePlayerNameAsync: RequestFailedException :  \n {ex.ErrorCode} \n {ex.Message}";
                if (LoginScreen.Instance != null)
                {
                    LoginScreen.Instance.ShowErrorMessage(message);
                }
                else
                {
                    Debug.LogException(ex);
                }
            }
        }


        private bool OnApplicationWantsToQuit()
        {
            if (!IsLoggedIn || PlayerData == null)
            {
                return true;
            }

            UnityServicesManager.Instance.OnApplicationWantsToQuit(PlayerData);
            PlayerData = null;
            return false;
        }
    }
}


// ---

// File: ConfigManager.cs

using Newtonsoft.Json;
using Unity.Services.Authentication;
using Unity.Services.RemoteConfig;
using UnityEngine;
using System.Collections.Generic;
using System.Threading.Tasks;
using System;
using OcentraAI.LLMGames.LLMServices;
using Sirenix.OdinInspector;

namespace OcentraAI.LLMGames.Authentication
{
    [Serializable]
    public class ConfigManager
    {
        [Serializable]
        public struct UserAttributes
        {
            public string UserId;
        }

        [Serializable]
        public struct AppAttributes
        {
            public string AppVersion;
            public string Platform;
        }

        [ShowInInspector]
        public Dictionary<string, LLMConfig> DefaultLLMConfigs { get; set; } = new Dictionary<string, LLMConfig>();

        [ShowInInspector]
        private Dictionary<string, LLMConfig> UserLLMConfigs { get; set; } = new Dictionary<string, LLMConfig>();


        public async Task FetchConfig()
        {
            UserAttributes userAttr = new UserAttributes
            {
                UserId = AuthenticationService.Instance.PlayerId,
            };

            AppAttributes appAttr = new AppAttributes
            {
                AppVersion = Application.version,
                Platform = Application.platform.ToString()
            };

            
            RemoteConfigService.Instance.FetchCompleted += ApplyRemoteSettings;
            await RemoteConfigService.Instance.FetchConfigsAsync(userAttr, appAttr);

            await TryGetAllConfigsFromCloud();
        }

        private void ApplyRemoteSettings(ConfigResponse configResponse)
        {
            //switch (configResponse.requestOrigin)
            //{
            //    case ConfigOrigin.Default:
            //        Debug.Log("No settings loaded this session; using default values.");
            //        break;
            //    case ConfigOrigin.Cached:
            //        Debug.Log("No settings loaded this session; using cached values from a previous session.");
            //        break;
            //    case ConfigOrigin.Remote:
            //        Debug.Log("New settings loaded this session; update values accordingly.");
            //        break;
            //}

            // Log all available keys and values
            //var allKeys = RemoteConfigService.Instance.appConfig.GetKeys();
            //foreach (var key in allKeys)
            //{
            //    var value = RemoteConfigService.Instance.appConfig.GetJson(key);
            //    Debug.Log($"Key: {key}, Value: {value}");
            //}

            foreach (LLMProvider provider in Enum.GetValues(typeof(LLMProvider)))
            {
                string configJson = RemoteConfigService.Instance.appConfig.GetJson(provider.ToString());
                //Debug.Log($"Fetched config for {provider}: {configJson}");
                if (!string.IsNullOrEmpty(configJson))
                {
                    try
                    {
                        LLMConfig config = JsonConvert.DeserializeObject<LLMConfig>(configJson);
                        DefaultLLMConfigs[$"{provider}"] = config;
                        //Debug.Log($"Configuration Loaded for {provider}: {configJson}");
                    }
                    catch (JsonException jsonEx)
                    {
                        Debug.LogError($"Failed to deserialize JSON for {provider}: {jsonEx.Message}");
                    }
                }
                else
                {
                    Debug.LogWarning($"{provider} configuration is missing or empty.");
                }
            }
        }



        public bool TryGetConfigForProvider(string provider, out LLMConfig config)
        {
            if (UserLLMConfigs.TryGetValue(provider, out LLMConfig foundUserConfig))
            {
                config = foundUserConfig;
                return true;
            }

            if (DefaultLLMConfigs.TryGetValue(provider, out LLMConfig foundDefaultConfig))
            {
                config = foundDefaultConfig;
                return true;
            }

            config = null;
            Debug.LogError($"Configuration for provider {provider} not found.");
            return false;
        }

        public void UpdateApiKey(string provider, string newApiKey)
        {
            if (UserLLMConfigs.TryGetValue(provider, out LLMConfig userLLMConfig))
            {
                userLLMConfig.ApiKey = newApiKey;
                UserLLMConfigs[provider] = userLLMConfig;
                Debug.Log($"API key updated for {provider}");
            }
        }

        public async Task AddNewConfig(string provider, string endpoint, string apiKey, string apiUrl, string model, int maxTokens, double temperature, bool stream)
        {
            LLMConfig newConfig = new LLMConfig
            {
                Endpoint = endpoint,
                ApiKey = apiKey,
                ApiUrl = apiUrl,
                Model = model,
                MaxTokens = maxTokens,
                Temperature = temperature,
                Stream = stream
            };

            if (!LLMManager.Instance.ValidateConfig(newConfig))
            {
                return;
            }

            if (!UserLLMConfigs.TryAdd(provider, newConfig))
            {
                UpdateApiKey(provider, apiKey);
            }


            await SaveAllConfigsToCloud();
            LLMManager.Instance.SetLLMProvider(newConfig);
        }
        public async Task SaveAllConfigsToCloud()
        {
            try
            {
                string jsonData = JsonUtility.ToJson(UserLLMConfigs);
                Dictionary<string, object> data = new Dictionary<string, object> { { nameof(UserLLMConfigs), jsonData } };
                await UnityServicesManager.Instance.CloudSaveService.Data.Player.SaveAsync(data);
                Debug.Log("All configurations saved to the cloud.");
            }
            catch (Exception ex)
            {
                Debug.LogError($"Error saving all configurations: {ex.Message}");
            }
        }

        public async Task<bool> TryGetAllConfigsFromCloud()
        {
           // Debug.Log("Attempting to retrieve all configurations from the cloud...");

            while (!AuthenticationManager.Instance.IsLoggedIn)
            {
               // Debug.Log("Waiting for user to log in...");
                await Task.Delay(100);
            }

            try
            {
                Dictionary<string, Unity.Services.CloudSave.Models.Item> data = await UnityServicesManager.Instance.CloudSaveService.Data.Player.LoadAsync(new HashSet<string> { nameof(UserLLMConfigs) });
                if (data.TryGetValue(nameof(UserLLMConfigs), out Unity.Services.CloudSave.Models.Item keyValue))
                {
                    Dictionary<string, LLMConfig> configs = JsonUtility.FromJson<Dictionary<string, LLMConfig>>(keyValue.Value.GetAsString());
                    UserLLMConfigs = configs ?? new Dictionary<string, LLMConfig>();
                   // Debug.Log("All configurations retrieved from the cloud.");
                    return true;
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"Error retrieving all configurations: {ex.Message}");
            }
            return false;
        }
    }
}


// ---

// File: PlayerData.cs

namespace OcentraAI.LLMGames.Authentication
{
    [System.Serializable]
    public class PlayerData
    {
        public string PlayerName;
        public string Email;
        public string PlayerID { get; internal set; }
    }
}

// ---

// File: UnityServicesManager.cs

using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;
using Sirenix.OdinInspector;
using Unity.Services.Analytics;
using Unity.Services.Authentication;
using Unity.Services.CloudSave;
using Unity.Services.Core;
using UnityEngine;

namespace OcentraAI.LLMGames.Authentication
{
    public class UnityServicesManager : MonoBehaviour
    {
        public IAnalyticsService AnalyticsService => Unity.Services.Analytics.AnalyticsService.Instance;
        public ICloudSaveService CloudSaveService => Unity.Services.CloudSave.CloudSaveService.Instance;
        public static UnityServicesManager Instance { get; private set; }

        [ShowInInspector]
        public ConfigManager ConfigManager { get; private set; }

        public bool IsInitialized { get; private set; } = false;

        async void Awake()
        {
            if (Instance != null && Instance != this)
            {
                Destroy(gameObject);
            }
            else
            {
                Instance = this;
                DontDestroyOnLoad(gameObject);
                await InitializeUnityServices();
            }
        }


        private async Task InitializeUnityServices()
        {
            try
            {
                InitializationOptions options = new InitializationOptions();
                options.SetOption("com.unity.services.core.environment-name", "production");
                await UnityServices.InitializeAsync(options);
                AnalyticsService.StartDataCollection();
                ConfigManager = new ConfigManager();
                await ConfigManager.FetchConfig();
                IsInitialized = true;
            }
            catch (Exception e)
            {
                Debug.LogException(e);
            }
        }

        public async Task SavePlayerDataToCloud(string key, PlayerData playerData)
        {
            try
            {
                string jsonData = JsonUtility.ToJson(playerData);
                Dictionary<string, object> data = new Dictionary<string, object> { { key, jsonData } };
                await CloudSaveService.Data.Player.SaveAsync(data);
            }
            catch (Exception ex)
            {
                Debug.LogError($"Error saving player data: {ex.Message}");

            }

        }

        public async Task SavePlayerDataToCloud(PlayerData playerData)
        {
            try
            {
                string jsonData = JsonUtility.ToJson(playerData);
                Dictionary<string, object> data = new Dictionary<string, object> { { playerData.PlayerID, jsonData } };
                await CloudSaveService.Data.Player.SaveAsync(data);
            }
            catch (Exception ex)
            {
                Debug.LogError($"Error saving player data: {ex.Message}");

            }

        }

        public async Task<(bool success, PlayerData playerData)> TryGetPlayerDataFromCloud(string key)
        {
            try
            {
                Dictionary<string, Unity.Services.CloudSave.Models.Item> data = await CloudSaveService.Data.Player.LoadAsync(new HashSet<string> { AuthenticationService.Instance.PlayerId });
                if (data.TryGetValue(key, out Unity.Services.CloudSave.Models.Item keyValue))
                {
                    PlayerData playerData = JsonUtility.FromJson<PlayerData>(keyValue.Value.GetAsString());
                    return (true, playerData);
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"Error loading player data: {ex.Message}");
            }

            return (false, null);
        }



        public async Task<(bool, string)> TryGetPlayerName(string key)
        {
            try
            {
                (bool success, PlayerData playerData) = await TryGetPlayerDataFromCloud(key);
                if (success)
                {
                    if (string.IsNullOrEmpty(playerData.PlayerName))
                    {
                        return (true, playerData.PlayerName);
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError($"Error Getting player Name: {e.Message}");

            }



            return (false, null);
        }

        public async Task<(bool, string)> TryGetPlayerEmail(string key)
        {
            try
            {
                (bool success, PlayerData playerData) = await TryGetPlayerDataFromCloud(key);
                if (success)
                {
                    if (string.IsNullOrEmpty(playerData.Email))
                    {
                        return (true, playerData.PlayerName);
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError($"Error Getting player Email: {e.Message}");
            }


            return (false, null);
        }

        public IEnumerator UpdatePlayerDataOnQuit(PlayerData playerData)
        {
            if (playerData != null)
            {


                Task saveTask = SavePlayerDataToCloud(playerData);

                while (!saveTask.IsCompleted)
                {
                    yield return null;
                }

                if (saveTask.IsFaulted)
                {
                    Debug.LogError($"Error occurred while saving player data: {saveTask.Exception} ");
                }
                else
                {
                    Debug.Log("Player data saved successfully.");
                }


                AuthenticationService.Instance.SignOut();
                Application.Quit();
            }
        }

        public void OnApplicationWantsToQuit(PlayerData playerData)
        {
            // StartCoroutine(UpdatePlayerDataOnQuit(playerData));

        }
    }
}

// ---

// File: CardAssetPostprocessor.cs

using OcentraAI.LLMGames;
using OcentraAI.LLMGames.Scriptable;
using UnityEditor;
using UnityEngine;

public class CardAssetPostprocessor : AssetPostprocessor
{
    private static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths)
    {
        foreach (string assetPath in importedAssets)
        {
            Card card = AssetDatabase.LoadAssetAtPath<Card>(assetPath);
            if (card != null)
            {
                string resourcesPath = "Assets/Resources/Cards/";
                if (!assetPath.StartsWith(resourcesPath))
                {
                    string assetName = System.IO.Path.GetFileName(assetPath);
                    string newAssetPath = resourcesPath + assetName;

                    // Ensure the directory exists
                    System.IO.Directory.CreateDirectory(resourcesPath);

                    // Move the asset to the new path
                    AssetDatabase.MoveAsset(assetPath, newAssetPath);
                    Debug.Log($"Moved card to: {newAssetPath}");
                }
            }
        }
    }
}

// ---

// File: TransformExtensions.cs

using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;
using Object = UnityEngine.Object;

namespace OcentraAI.LLMGames.Extensions
{
    public static class TransformExtensions
    {
        /// <summary>
        /// Recursively searches for a child Transform by name.
        /// </summary>
        /// <param name="parent">The parent Transform to start the search from.</param>
        /// <param name="name">The name of the child Transform to search for.</param>
        /// <returns>The found child Transform, or null if not found.</returns>
        public static Transform FindChildRecursively(this Transform parent, string name)
        {
            foreach (Transform child in parent)
            {
                if (child.name == name)
                    return child;
                var result = child.FindChildRecursively(name);
                if (result != null)
                    return result;
            }
            return null;
        }

        /// <summary>
        /// Recursively searches for a child component of a specified type.
        /// </summary>
        /// <typeparam name="T">The type of component to search for.</typeparam>
        /// <param name="parent">The parent Transform to start the search from.</param>
        /// <returns>The found component of type T, or null if not found.</returns>
        public static T FindChildRecursively<T>(this Transform parent) where T : Component
        {
            foreach (Transform child in parent)
            {
                T component = child.GetComponent<T>();
                if (component != null)
                    return component;
                var result = child.FindChildRecursively<T>();
                if (result != null)
                    return result;
            }
            return null;
        }

        /// <summary>
        /// Recursively searches for a child component of a specified type with a specified name.
        /// </summary>
        /// <typeparam name="T">The type of component to search for.</typeparam>
        /// <param name="parent">The parent Transform to start the search from.</param>
        /// <param name="name">The name of the child Transform to search for.</param>
        /// <returns>The found component of type T with the specified name, or null if not found.</returns>
        public static T FindChildRecursively<T>(this Transform parent, string name) where T : Component
        {
            foreach (Transform child in parent)
            {
                if (child.name == name)
                {
                    T component = child.GetComponent<T>();
                    if (component != null)
                        return component;
                }
                var result = child.FindChildRecursively<T>(name);
                if (result != null)
                    return result;
            }
            return null;
        }

        /// <summary>
        /// Attempts to find a GameObject by name from a collection of GameObjects.
        /// </summary>
        /// <param name="nameOfGameobject">The name of the GameObject to find.</param>
        /// <param name="allGameObjects">The collection of GameObjects to search through.</param>
        /// <param name="go">The found GameObject, if found.</param>
        /// <returns>True if the GameObject is found, otherwise false.</returns>
        public static bool TryFindGameObjectOfName(string nameOfGameobject, IEnumerable<GameObject> allGameObjects, out GameObject go)
        {
            go = null;
            foreach (GameObject gameObject in allGameObjects)
            {
                if (gameObject.name == nameOfGameobject)
                {
                    go = gameObject;
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Recursively searches for a child GameObject by name.
        /// </summary>
        /// <param name="parent">The parent Transform to start the search from.</param>
        /// <param name="childName">The name of the child GameObject to search for.</param>
        /// <returns>The found child GameObject, or null if not found.</returns>
        public static GameObject RecursiveFindChildGameObject(this Transform parent, string childName)
        {
            var childTransform = parent.FindChildRecursively(childName);
            return childTransform != null ? childTransform.gameObject : null;
        }

        /// <summary>
        /// Recursively searches for a child Transform by name.
        /// </summary>
        /// <param name="parent">The parent GameObject to start the search from.</param>
        /// <param name="childName">The name of the child Transform to search for.</param>
        /// <returns>The found child Transform, or null if not found.</returns>
        public static Transform RecursiveFindChild(GameObject parent, string childName)
        {
            return parent.transform.FindChildRecursively(childName);
        }

        /// <summary>
        /// Attempts to find a component of a specified type on a child GameObject with a specified name.
        /// </summary>
        /// <typeparam name="T">The type of component to search for.</typeparam>
        /// <param name="parent">The parent Transform to start the search from.</param>
        /// <param name="childName">The name of the child GameObject to search for.</param>
        /// <param name="foundChild">The found component, if found.</param>
        /// <returns>True if the component is found, otherwise false.</returns>
        public static bool TryFindComponent<T>(this Transform parent, string childName, out T foundChild) where T : Component
        {
            var transform = parent.FindChildRecursively(childName);
            if (transform != null)
            {
                foundChild = transform.GetComponent<T>();
                return foundChild != null;
            }

            foundChild = null;
            return false;
        }

        /// <summary>
        /// Retrieves the first child Transform with the specified name.
        /// </summary>
        /// <param name="parent">The parent Transform to start the search from.</param>
        /// <param name="childName">The name of the child Transform to search for.</param>
        /// <returns>The found child Transform, or null if not found.</returns>
        public static Transform GetChildWithName(this Transform parent, string childName)
        {
            return parent.GetComponentsInChildren<Transform>(true).FirstOrDefault(child => child.name == childName);
        }

        /// <summary>
        /// Clears all child GameObjects of a Transform.
        /// </summary>
        /// <param name="transform">The parent Transform.</param>
        /// <returns>The parent Transform.</returns>
        public static Transform ClearChildren(this Transform transform)
        {
            foreach (Transform child in transform)
            {
                Object.Destroy(child.gameObject);
            }
            return transform;
        }

        /// <summary>
        /// Gets a list of child GameObjects of a Transform.
        /// </summary>
        /// <param name="transform">The parent Transform.</param>
        /// <returns>A list of child GameObjects.</returns>
        public static List<GameObject> GetChildrenGameObject(this Transform transform)
        {
            return (from Transform child in transform select child.gameObject).ToList();
        }

#if UNITY_EDITOR
        /// <summary>
        /// Retrieves an array of assets of a specified type.
        /// </summary>
        /// <typeparam name="T">The type of assets to retrieve.</typeparam>
        /// <returns>An array of assets.</returns>
        public static T[] GetAssetArrayOfType<T>() where T : ScriptableObject =>
            UnityEditor.AssetDatabase.FindAssets($"t: {typeof(T).Name}")
                .ToList()
                .Select(UnityEditor.AssetDatabase.GUIDToAssetPath)
                .Select(UnityEditor.AssetDatabase.LoadAssetAtPath<T>)
                .ToArray();

        /// <summary>
        /// Retrieves a list of assets of a specified type.
        /// </summary>
        /// <typeparam name="T">The type of assets to retrieve.</typeparam>
        /// <returns>A list of assets.</returns>
        public static List<T> GetAssetListOfType<T>() where T : ScriptableObject =>
            UnityEditor.AssetDatabase.FindAssets($"t: {typeof(T).Name}")
                .ToList()
                .Select(UnityEditor.AssetDatabase.GUIDToAssetPath)
                .Select(UnityEditor.AssetDatabase.LoadAssetAtPath<T>)
                .ToList();

        /// <summary>
        /// Gets the full path of the currently selected directory in the Unity editor.
        /// </summary>
        /// <returns>The full path of the selected directory.</returns>
        public static string GetClickedDirFullPath()
        {
            string path = UnityEditor.AssetDatabase.GetAssetPath(UnityEditor.Selection.activeObject);

            if (path == "")
            {
                path = "Assets";
            }
            else if (Path.GetExtension(path) != "")
            {
                path = path.Replace(Path.GetFileName(UnityEditor.AssetDatabase.GetAssetPath(UnityEditor.Selection.activeObject)), "");
            }

            return path;
        }

        /// <summary>
        /// Retrieves a list of assets at a specified path.
        /// </summary>
        /// <typeparam name="T">The type of assets to retrieve.</typeparam>
        /// <param name="path">The path to search for assets.</param>
        /// <returns>A list of assets.</returns>
        public static List<T> GetAtPath<T>(string path)
        {
            var al = new List<object>();
            string[] fileEntries = Directory.GetFiles(Application.dataPath + "/" + path);
            foreach (string fileName in fileEntries)
            {
                var name = Path.GetFileName(fileName);
                string localPath = Path.Combine("Assets/", $"{path}/{name}");

                Object t = UnityEditor.AssetDatabase.LoadAssetAtPath(localPath, typeof(T));

                if (t != null)
                {
                    al.Add(t);
                }
            }
            T[] result = new T[al.Count];
            for (int i = 0; i < al.Count; i++)
                result[i] = (T)al[i];

            return result.ToList();
        }
#endif
    }
}


// ---

// File: GameOverScreen.cs


using UnityEngine;
using UnityEngine.UI;
using TMPro;
using Sirenix.OdinInspector;
using OcentraAI.LLMGames.Extensions;
using OcentraAI.LLMGames.ThreeCardBrag.Manager;

namespace OcentraAI.LLMGames.Screens
{
    public class GameOverScreen : UIScreen<GameOverScreen>
    {
        [ShowInInspector, Required]
        public TextMeshProUGUI GameOverText { get; private set; }

        [ShowInInspector, Required]
        public TextMeshProUGUI ScoreText { get; private set; }

        [ShowInInspector, Required]
        public Button PlayAgainButton { get; private set; }

        [ShowInInspector, Required]
        public Button MainMenuButton { get; private set; }

        protected override void Awake()
        {
            base.Awake();
            InitReferences();
        }

        void OnValidate()
        {
            InitReferences();
        }

        private void InitReferences()
        {
            GameOverText = transform.FindChildRecursively<TextMeshProUGUI>(nameof(GameOverText));
            ScoreText = transform.FindChildRecursively<TextMeshProUGUI>(nameof(ScoreText));
            PlayAgainButton = transform.FindChildRecursively<Button>(nameof(PlayAgainButton));
            MainMenuButton = transform.FindChildRecursively<Button>(nameof(MainMenuButton));
        }

        public override void OnShowScreen(bool first)
        {
            base.OnShowScreen(first);
            InitializeGameOverScreen();
        }

        private void InitializeGameOverScreen()
        {
            PlayAgainButton.onClick.AddListener(PlayAgain);
            MainMenuButton.onClick.AddListener(ReturnToMainMenu);
            UpdateScore();
        }

        private void UpdateScore()
        {
            // Implement score update logic here
            ScoreText.text = $"Your Score: {GameManager.Instance.ScoreKeeper.HumanTotalWins}";
        }

        private async void PlayAgain()
        {
            PlaySelectionSound();
            await GameManager.Instance.StartNewGameAsync();
            HideScreen();
        }

        private void ReturnToMainMenu()
        {
            PlaySelectionSound();
            UIScreen<WelcomeScreen>.ShowScreen();
            HideScreen();
        }
    }
}


// ---

// File: HomeScreen.cs

using UnityEngine;
using UnityEngine.UI;
using TMPro;
using Sirenix.OdinInspector;
using System.Collections.Generic;
using OcentraAI.LLMGames.Extensions;

namespace OcentraAI.LLMGames.Screens
{
    public class HomeScreen : UIScreen<HomeScreen>
    {
        [ShowInInspector, Required]
        public TextMeshProUGUI TitleText { get; private set; }

        [ShowInInspector, Required]
        public TextMeshProUGUI TaglineText { get; private set; }

        [ShowInInspector, Required]
        public Button ThreeCardBragButton { get; private set; }

        [ShowInInspector, Required]
        public List<Button> OtherGameButtons { get; private set; } = new List<Button>();

        [ShowInInspector, Required]
        public Button SettingsButton { get; private set; }

        [ShowInInspector, Required]
        public Button QuitButton { get; private set; }

        protected override void Awake()
        {
            base.Awake();
            InitReferences();
        }

        void OnValidate()
        {
            InitReferences();
        }

        private void InitReferences()
        {
            TitleText = transform.FindChildRecursively<TextMeshProUGUI>(nameof(TitleText));
            TaglineText = transform.FindChildRecursively<TextMeshProUGUI>(nameof(TaglineText));
            ThreeCardBragButton = transform.FindChildRecursively<Button>(nameof(ThreeCardBragButton));
            SettingsButton = transform.FindChildRecursively<Button>(nameof(SettingsButton));
            QuitButton = transform.FindChildRecursively<Button>(nameof(QuitButton));

            // Find other game buttons (for future games)
            Button OtherGameButton = transform.FindChildRecursively<Button>("OtherGameButton");
            OtherGameButtons = new List<Button> { OtherGameButton };
        }

        public override void OnShowScreen(bool first)
        {
            base.OnShowScreen(first);
            InitializeHomeScreen();
        }

        private void InitializeHomeScreen()
        {
            TitleText.text = "LLM Games";
            TaglineText.text = "Challenge the AI, Master the Game!";

            ThreeCardBragButton.onClick.AddListener(StartThreeCardBrag);
            SettingsButton.onClick.AddListener(OpenSettings);
            QuitButton.onClick.AddListener(QuitGame);

            // Set up other game buttons (for future games)
            foreach (var button in OtherGameButtons)
            {
                button.onClick.AddListener(() => Debug.Log("Other game selected (not implemented yet)"));
            }
        }

        private void StartThreeCardBrag()
        {
            PlaySelectionSound();
            // GameManager.Instance.StartThreeCardBrag();
        }

        private void OpenSettings()
        {
            PlaySelectionSound();
            UIScreen<SettingsScreen>.ShowScreen();
        }

        public override void QuitGame()
        {
            base.QuitGame();
        }
    }
}


// ---

// File: LoginScreen.cs

using UnityEngine;
using UnityEngine.UI;
using TMPro;
using Sirenix.OdinInspector;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using OcentraAI.LLMGames.Extensions;
using Unity.Services.Authentication;
using System.Threading.Tasks;
using OcentraAI.LLMGames.Authentication;

namespace OcentraAI.LLMGames.Screens
{
    public class LoginScreen : UIScreen<LoginScreen>
    {
        [ShowInInspector, Required] public GameObject AuthenticationUI { get; private set; }
        [ShowInInspector, Required] public GameObject UserAndEmailRegistrationUI { get; private set; }

        [ShowInInspector, Required] public Button SignInWithName { get; private set; }
        [ShowInInspector, Required] public Button SignInWithUnity { get; private set; }
        [ShowInInspector, Required] public Button Create { get; private set; }
        [ShowInInspector, Required] public Button OkButton { get; private set; }
        [ShowInInspector, Required] public Button SubmitNameAndEmail { get; private set; }
        [ShowInInspector, Required] public Button ShowPassword { get; private set; }
        [ShowInInspector, Required] public Button HidePassword { get; private set; }
        [ShowInInspector, Required] public Button ShowVerifyPassword { get; private set; }
        [ShowInInspector, Required] public Button HideVerifyPassword { get; private set; }

        [ShowInInspector, Required] public TMP_InputField UserNameInputField { get; private set; }
        [ShowInInspector, Required] public TMP_InputField PasswordInputField { get; private set; }
        [ShowInInspector, Required] public TMP_InputField PasswordInputVerifyField { get; private set; }
        [ShowInInspector, Required] public TMP_InputField EmailInputField { get; private set; }
        [ShowInInspector, Required] public TMP_InputField SubmitEmailInputField { get; private set; }
        [ShowInInspector, Required] public TMP_InputField SubmitUserNameInputField { get; private set; }

        [ShowInInspector, Required] public TextMeshProUGUI ErrorMessage { get; private set; }
        [ShowInInspector, Required] public TextMeshProUGUI FieldValidator { get; private set; }
        [ShowInInspector, Required] public GameObject ErrorPanel { get; private set; }

        [ReadOnly]
        public static Regex NameRegex => new Regex(@"^[a-zA-Z0-9.\-@_]{3,20}$");

        [ReadOnly]
        public static Regex EmailRegex => new Regex(@"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$");

        [ReadOnly]
        public static Regex PasswordRegex => new Regex(@"^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[^\da-zA-Z]).{8,30}$");

        protected override void Awake()
        {
            base.Awake();
            InitReferences();
        }

        void OnValidate()
        {
            InitReferences();
        }

        private void InitReferences()
        {
            AuthenticationUI = transform.RecursiveFindChildGameObject(nameof(AuthenticationUI));
            UserAndEmailRegistrationUI = transform.RecursiveFindChildGameObject(nameof(UserAndEmailRegistrationUI));

            SignInWithName = transform.FindChildRecursively<Button>(nameof(SignInWithName));
            SignInWithUnity = transform.FindChildRecursively<Button>(nameof(SignInWithUnity));
            Create = transform.FindChildRecursively<Button>(nameof(Create));
            SubmitNameAndEmail = transform.FindChildRecursively<Button>(nameof(SubmitNameAndEmail));
            ShowPassword = transform.FindChildRecursively<Button>(nameof(ShowPassword));
            HidePassword = transform.FindChildRecursively<Button>(nameof(HidePassword));
            ShowVerifyPassword = transform.FindChildRecursively<Button>(nameof(ShowVerifyPassword));
            HideVerifyPassword = transform.FindChildRecursively<Button>(nameof(HideVerifyPassword));

            UserNameInputField = transform.FindChildRecursively<TMP_InputField>(nameof(UserNameInputField));
            PasswordInputField = transform.FindChildRecursively<TMP_InputField>(nameof(PasswordInputField));
            PasswordInputVerifyField = transform.FindChildRecursively<TMP_InputField>(nameof(PasswordInputVerifyField));
            EmailInputField = transform.FindChildRecursively<TMP_InputField>(nameof(EmailInputField));
            SubmitEmailInputField = transform.FindChildRecursively<TMP_InputField>(nameof(SubmitEmailInputField));
            SubmitUserNameInputField = transform.FindChildRecursively<TMP_InputField>(nameof(SubmitUserNameInputField));

            ErrorMessage = transform.FindChildRecursively<TextMeshProUGUI>(nameof(ErrorMessage));
            FieldValidator = transform.FindChildRecursively<TextMeshProUGUI>(nameof(FieldValidator));
            ErrorPanel = transform.RecursiveFindChildGameObject(nameof(ErrorPanel));

            OkButton = transform.FindChildRecursively<Button>(nameof(OkButton));
        }

        public override void OnShowScreen(bool first)
        {
            base.OnShowScreen(first);
            InitializeLoginScreen();
        }

        private void InitializeLoginScreen()
        {
            if (UserNameInputField != null)
            {
                UserNameInputField.onValueChanged.AddListener(arg0 => UserNameChanged(arg0, UserNameInputField));
            }

            if (SubmitUserNameInputField != null)
            {
                SubmitUserNameInputField.onValueChanged.AddListener(arg0 => UserNameChanged(arg0, SubmitUserNameInputField));
            }

            if (EmailInputField != null)
            {
                EmailInputField.onValueChanged.AddListener(arg0 => EmailChanged(arg0, EmailInputField));
            }

            if (SubmitEmailInputField != null)
            {
                SubmitEmailInputField.onValueChanged.AddListener(arg0 => EmailChanged(arg0, SubmitEmailInputField));
            }

            if (PasswordInputField != null)
            {
                PasswordInputField.onValueChanged.AddListener(unknown => PasswordChanged(PasswordInputField));
            }

            if (PasswordInputVerifyField != null)
            {
                PasswordInputVerifyField.onValueChanged.AddListener(typedPassword => PasswordVerifyChanged(PasswordInputVerifyField));
            }

            SignInWithName.onClick.AddListener(async () => await AuthenticationManager.Instance.PerformAuthenticationAsync(AuthenticationService.Instance.SignInWithUsernamePasswordAsync, UserNameInputField.text, PasswordInputField.text, ShowErrorMessage));
            Create.onClick.AddListener(async () => await AuthenticationManager.Instance.PerformAuthenticationAsync(AuthenticationService.Instance.SignUpWithUsernamePasswordAsync, UserNameInputField.text, PasswordInputField.text, ShowErrorMessage));
            SignInWithUnity.onClick.AddListener(async () => await AuthenticationManager.Instance.StartSignInAsync(ShowErrorMessage));
            OkButton.onClick.AddListener(() => { ErrorMessage.text = string.Empty; ErrorPanel.SetActive(false); });

            HidePassword.onClick.AddListener(() => SwitchInputType(TMP_InputField.ContentType.Password));
            ShowPassword.onClick.AddListener(() => SwitchInputType(TMP_InputField.ContentType.Standard));
            HideVerifyPassword.onClick.AddListener(() => SwitchInputType(TMP_InputField.ContentType.Password));
            ShowVerifyPassword.onClick.AddListener(() => SwitchInputType(TMP_InputField.ContentType.Standard));

            ErrorPanel.SetActive(false);
        }



        private void SwitchInputType(TMP_InputField.ContentType inputType)
        {
            PasswordInputField.contentType = inputType;
            PasswordInputVerifyField.contentType = inputType;
            PasswordInputField.ForceLabelUpdate();
            PasswordInputVerifyField.ForceLabelUpdate();
        }

        private void UserNameChanged(string _, TMP_InputField userNameInputField)
        {
            string username = userNameInputField.text;
            userNameInputField.textComponent.color = string.IsNullOrEmpty(username) || !NameRegex.IsMatch(username) ? Color.red : Color.black;

            List<string> errors = new List<string>();

            if (string.IsNullOrEmpty(username))
            {
                FieldValidator.text = "Username cannot be empty.";
                return; // If empty, no need to check further criteria.
            }

            if (username.Length < 3)
                errors.Add("be at least 3 characters long");

            if (username.Length > 20)
                errors.Add("not exceed 20 characters");

            if (!Regex.IsMatch(username, @"^[a-zA-Z0-9.\-@_]+$"))
                errors.Add("only contain letters, numbers, dots, hyphens, at symbols, and underscores");

            if (errors.Count == 0)
            {
                FieldValidator.text = "";
            }
            else
            {
                FieldValidator.text = "Username must " + string.Join(", ", errors) + ".";
            }

            SignInWithName.enabled = ValidateUserAndPassword();
            Create.enabled = ValidateUserAndPassword();
        }

        private void EmailChanged(string _, TMP_InputField inputField)
        {
            string email = inputField.text;
            inputField.textComponent.color = string.IsNullOrEmpty(email) || !EmailRegex.IsMatch(email) ? Color.red : Color.black;

            List<string> errors = new List<string>();

            if (string.IsNullOrEmpty(email))
            {
                FieldValidator.text = "Email cannot be empty.";
                return;
            }

            if (email.Length < 3)
                errors.Add("be at least 3 characters long");

            if (email.Length > 254)
                errors.Add("not exceed 254 characters");

            if (!email.Contains("@"))
                errors.Add("contain @");

            if (!email.Contains("."))
                errors.Add("contain dot (.)");

            if (email.IndexOf('@') != email.LastIndexOf('@'))
                errors.Add("contain only one @ symbol");

            if (email.Contains(".."))
                errors.Add("not have consecutive dots (.)");

            if (email.StartsWith("."))
                errors.Add("not start with a dot (.)");

            if (email.EndsWith("."))
                errors.Add("not end with a dot (.)");

            if (email.IndexOf('@') > email.LastIndexOf('.'))
                errors.Add("have the @ symbol before the dot (.) in the domain");

            if (errors.Count == 0)
            {
                FieldValidator.text = "";
            }
            else
            {
                FieldValidator.text = "email must " + string.Join(", ", errors) + ".";
            }
        }

        private void PasswordChanged(TMP_InputField tmpInputField)
        {
            string password = tmpInputField.text;
            tmpInputField.textComponent.color = string.IsNullOrEmpty(password) || !PasswordRegex.IsMatch(password) ? Color.red : Color.black;

            List<string> errors = new List<string>();

            if (string.IsNullOrEmpty(password))
            {
                FieldValidator.text = "Password cannot be empty.";
                return; // If empty, no need to check further criteria.
            }

            if (password.Length < 8)
                errors.Add("be at least 8 characters long");

            if (password.Length > 30)
                errors.Add("not exceed 30 characters");

            if (!Regex.IsMatch(password, @"[a-z]"))
                errors.Add("one lowercase letter");

            if (!Regex.IsMatch(password, @"[A-Z]"))
                errors.Add("one uppercase letter");

            if (!Regex.IsMatch(password, @"\d"))
                errors.Add("one digit");

            if (!Regex.IsMatch(password, @"[^\da-zA-Z]"))
                errors.Add("one symbol");

            if (errors.Count == 0)
            {
                FieldValidator.text = "";
            }
            else
            {
                FieldValidator.text = "Password must contain at least " + string.Join(',', errors) + ".";
            }
            SignInWithName.enabled = ValidateUserAndPassword();
        }

        private void PasswordVerifyChanged(TMP_InputField passwordInputVerifyField)
        {
            if (PasswordInputField.text == passwordInputVerifyField.text)
            {
                FieldValidator.text = "";
                FieldValidator.color = Color.black;
            }
            else
            {
                FieldValidator.text = "Password Don't Match!";
                FieldValidator.color = Color.red;
            }
            passwordInputVerifyField.textComponent.color = PasswordInputField.text == passwordInputVerifyField.text ? Color.black : Color.red;
            SignInWithName.enabled = ValidateUserAndPassword();
            Create.enabled = ValidateUserPasswordAndVerifyPassword();
        }

        public bool ValidateUserAndPassword()
        {
            return !string.IsNullOrEmpty(UserNameInputField.text)
                   && NameRegex.IsMatch(UserNameInputField.text)
                   && !string.IsNullOrEmpty(PasswordInputField.text)
                   && PasswordRegex.IsMatch(PasswordInputField.text);
        }

        private bool ValidateUserPasswordAndVerifyPassword()
        {
            return !string.IsNullOrEmpty(UserNameInputField.text)
                   && NameRegex.IsMatch(UserNameInputField.text)
                   && !string.IsNullOrEmpty(PasswordInputField.text)
                   && PasswordRegex.IsMatch(PasswordInputField.text)
                   && !string.IsNullOrEmpty(PasswordInputVerifyField.text)
                   && PasswordRegex.IsMatch(PasswordInputVerifyField.text);
        }


        public Task<(string userName, string email)> ShowUserNameAndEmailUI()
        {
            UserAndEmailRegistrationUI.SetActive(true);
            AuthenticationUI.SetActive(false);

            var tcs = new TaskCompletionSource<(string userName, string email)>();

            void OnClick()
            {
                string userName = SubmitUserNameInputField.text;
                string email = SubmitEmailInputField.text;

                SubmitNameAndEmail.onClick.RemoveListener(OnClick);
                UserAndEmailRegistrationUI.SetActive(false);
                tcs.SetResult((userName, email));
            }

            SubmitNameAndEmail.onClick.AddListener(OnClick);

            return tcs.Task;
        }

        public void ShowErrorMessage(string message)
        {
            if (ErrorMessage != null)
            {
                ErrorMessage.text += $"\n + {message}";
            }

            if (ErrorPanel != null)
            {
                ErrorPanel.SetActive(true);
            }
        }
        public void UpdateButtonInteractability(bool interactable)
        {
            SignInWithName.interactable = interactable;
            Create.interactable = interactable;
            SignInWithUnity.interactable = interactable;
        }
        public void OnAuthenticationCompleted()
        {


            if (AuthenticationUI != null)
            {
                AuthenticationUI.SetActive(false);
            }

            AuthenticationManager.Instance.OnAuthenticationCompleted();
        }
    }
}


// ---

// File: PauseScreen.cs

using OcentraAI.LLMGames.Extensions;
using UnityEngine;
using UnityEngine.UI;
using Sirenix.OdinInspector;

namespace OcentraAI.LLMGames.Screens
{
    public class PauseScreen : UIScreen<PauseScreen>
    {
        [ShowInInspector, Required]
        public Button ResumeButton { get; private set; }

        [ShowInInspector, Required]
        public Button OptionsButton { get; private set; }

        [ShowInInspector, Required]
        public Button QuitToMainMenuButton { get; private set; }

        protected override void Awake()
        {
            base.Awake();
            InitReferences();
        }

        void OnValidate()
        {
            InitReferences();
        }

        private void InitReferences()
        {
            ResumeButton = transform.FindChildRecursively<Button>(nameof(ResumeButton));
            OptionsButton = transform.FindChildRecursively<Button>(nameof(OptionsButton));
            QuitToMainMenuButton = transform.FindChildRecursively<Button>(nameof(QuitToMainMenuButton));
        }

        public override void OnShowScreen(bool first)
        {
            base.OnShowScreen(first);
            InitializePauseScreen();
        }

        private void InitializePauseScreen()
        {
            ResumeButton.onClick.AddListener(Resume);
            OptionsButton.onClick.AddListener(ShowOptions);
            QuitToMainMenuButton.onClick.AddListener(QuitToMainMenu);
        }

        private void Resume()
        {
            PlaySelectionSound();
           // GameManager.Instance.ResumeGame();
            HideScreen();
        }

        private void ShowOptions()
        {
            PlaySelectionSound();
            // Implement showing options screen logic here
        }

        private void QuitToMainMenu()
        {
            PlaySelectionSound();
           // GameManager.Instance.QuitToMainMenu();
            HideScreen();
        }
    }
}


// ---

// File: PurchaseScreen.cs

using OcentraAI.LLMGames.Extensions;
using OcentraAI.LLMGames.ThreeCardBrag.Manager;
using Sirenix.OdinInspector;
using TMPro;
using UnityEngine.UI;

namespace OcentraAI.LLMGames.Screens
{
    public class PurchaseScreen : UIScreen<PurchaseScreen>
    {
        [ShowInInspector, Required]
        public Button AuthenticateButton { get; private set; }

        [ShowInInspector, Required]
        public Button PurchaseCoinsButton { get; private set; }

        [ShowInInspector, Required]
        public Button PurchaseCardSkinButton { get; private set; }

        [ShowInInspector, Required]
        public Button PurchaseUpgradesButton { get; private set; }

        [ShowInInspector, Required]
        public TextMeshProUGUI CurrentCoinsText { get; private set; }

        [ShowInInspector, Required]
        public Button BackButton { get; private set; }

        protected override void Awake()
        {
            base.Awake();
            InitReferences();
        }

        void OnValidate()
        {
            InitReferences();
        }

        private void InitReferences()
        {
            AuthenticateButton = transform.FindChildRecursively<Button>(nameof(AuthenticateButton));
            PurchaseCoinsButton = transform.FindChildRecursively<Button>(nameof(PurchaseCoinsButton));
            PurchaseCardSkinButton = transform.FindChildRecursively<Button>(nameof(PurchaseCardSkinButton));
            PurchaseUpgradesButton = transform.FindChildRecursively<Button>(nameof(PurchaseUpgradesButton));
            CurrentCoinsText = transform.FindChildRecursively<TextMeshProUGUI>(nameof(CurrentCoinsText));
            BackButton = transform.FindChildRecursively<Button>(nameof(BackButton));
        }

        public override void OnShowScreen(bool first)
        {
            base.OnShowScreen(first);
            InitializePurchaseScreen();
        }

        private void InitializePurchaseScreen()
        {
            UpdateCurrentCoins();
            AuthenticateButton.onClick.AddListener(AuthenticateUser);
            PurchaseCoinsButton.onClick.AddListener(PurchaseCoins);
            PurchaseCardSkinButton.onClick.AddListener(PurchaseCardSkin);
            PurchaseUpgradesButton.onClick.AddListener(PurchaseUpgrades);
            BackButton.onClick.AddListener(GoBack);
        }

        private void UpdateCurrentCoins()
        {
            CurrentCoinsText.text = $"Current Coins: {GameManager.Instance.HumanPlayer.Coins}";
        }

        private void AuthenticateUser()
        {
            PlaySelectionSound();
            // todo Implement Unity authentication service logic 
        }

        private void PurchaseCoins()
        {
            PlaySelectionSound();
            //todo Implement coin purchase logic 
        }

        private void PurchaseCardSkin()
        {
            PlaySelectionSound();
            // todo Implement card skin purchase logic
        }

        private void PurchaseUpgrades()
        {
            PlaySelectionSound();
            // todo Implement upgrades purchase logic 
        }


    }
}


// ---

// File: RulesScreen.cs

using OcentraAI.LLMGames.Extensions;
using OcentraAI.LLMGames.Scriptable.ScriptableSingletons;
using Sirenix.OdinInspector;
using TMPro;
using UnityEngine.UI;

namespace OcentraAI.LLMGames.Screens
{
    public class RulesScreen : UIScreen<RulesScreen>
    {
        [ShowInInspector, Required]
        public TextMeshProUGUI RulesText { get; private set; }

        [ShowInInspector, Required]
        public Button BackButton { get; private set; }

        private GameInfo GameInfo { get; set; }

        protected override void Awake()
        {
            base.Awake();
            GameInfo = GameInfo.Instance;
            InitReferences();
        }

        void OnValidate()
        {
            InitReferences();
        }

        private void InitReferences()
        {
            RulesText = transform.FindChildRecursively<TextMeshProUGUI>(nameof(RulesText));
            BackButton = transform.FindChildRecursively<Button>(nameof(RulesText));
        }

        public override void OnShowScreen(bool first)
        {
            base.OnShowScreen(first);
            InitializeRulesScreen();
        }

        private void InitializeRulesScreen()
        {
            RulesText.text = GameInfo.GameRules;
            BackButton.onClick.AddListener(GoBack);
        }


    }
}


// ---

// File: SettingsScreen.cs

using UnityEngine;
using UnityEngine.UI;
using TMPro;
using Sirenix.OdinInspector;
using System.Collections.Generic;
using OcentraAI.LLMGames.Extensions;


namespace OcentraAI.LLMGames.Screens
{
    public class SettingsScreen : UIScreen<SettingsScreen>
    {
        private  string MusicVolume =>"MusicVolume";
        private string SFXVolume => "SFXVolume";
        private string LLMModel => "LLMModel";

        [ShowInInspector, Required]
        public GameObject GeneralSettingsTab { get; private set; }

        [ShowInInspector, Required]
        public GameObject LLMSettingsTab { get; private set; }

        [ShowInInspector, Required]
        public GameObject SkinSettingsTab { get; private set; }

        [ShowInInspector, Required]
        public GameObject CardSettingsTab { get; private set; }

        [ShowInInspector, Required]
        public List<Button> TabButtons { get; private set; } = new List<Button>();

        [ShowInInspector, Required]
        public Slider MusicVolumeSlider { get; private set; }

        [ShowInInspector, Required]
        public Slider SFXVolumeSlider { get; private set; }

        [ShowInInspector, Required]
        public Toggle FullscreenToggle { get; private set; }

        [ShowInInspector, Required]
        public TMP_Dropdown ResolutionDropdown { get; private set; }

        [ShowInInspector, Required]
        public TMP_Dropdown LLMModelDropdown { get; private set; }

        [ShowInInspector, Required]
        public Button ApplyButton { get; private set; }

        [ShowInInspector, Required]
        public Button BackButton { get; private set; }


        [ShowInInspector, Required]
        public Button GeneralTabButton { get; private set; }
        [ShowInInspector, Required]
        public Button LLMTabButton { get; private set; }
        [ShowInInspector, Required]
        public Button SkinTabButton { get; private set; }
        [ShowInInspector, Required]
        public Button CardTabButton { get; private set; }
        protected override void Awake()
        {
            base.Awake();
            InitReferences();
        }

        void OnValidate()
        {
            InitReferences();
        }

        private void InitReferences()
        {
            GeneralSettingsTab = transform.FindChildRecursively<Transform>(nameof(GeneralSettingsTab)).gameObject;
            LLMSettingsTab = transform.FindChildRecursively<Transform>(nameof(LLMSettingsTab)).gameObject;
            SkinSettingsTab = transform.FindChildRecursively<Transform>(nameof(SkinSettingsTab)).gameObject;
            CardSettingsTab = transform.FindChildRecursively<Transform>(nameof(CardSettingsTab)).gameObject;
            
            MusicVolumeSlider = transform.FindChildRecursively<Slider>(nameof(MusicVolumeSlider));
            SFXVolumeSlider = transform.FindChildRecursively<Slider>(nameof(SFXVolumeSlider));
            
            FullscreenToggle = transform.FindChildRecursively<Toggle>(nameof(FullscreenToggle));
            
            ResolutionDropdown = transform.FindChildRecursively<TMP_Dropdown>(nameof(ResolutionDropdown));
            LLMModelDropdown = transform.FindChildRecursively<TMP_Dropdown>(nameof(LLMModelDropdown));
            
            ApplyButton = transform.FindChildRecursively<Button>(nameof(ApplyButton));
            BackButton = transform.FindChildRecursively<Button>(nameof(BackButton));
            
            GeneralTabButton = transform.FindChildRecursively<Button>(nameof(GeneralTabButton));
            LLMTabButton = transform.FindChildRecursively<Button>(nameof(LLMTabButton));
            SkinTabButton = transform.FindChildRecursively<Button>(nameof(SkinTabButton));
            CardTabButton = transform.FindChildRecursively<Button>(nameof(CardTabButton));

            TabButtons = new List<Button>
            {
                GeneralTabButton,LLMTabButton,SkinTabButton,CardTabButton
      
            };
        }

        public override void OnShowScreen(bool first)
        {
            base.OnShowScreen(first);
            InitializeSettingsScreen();
        }

        private void InitializeSettingsScreen()
        {
            LoadCurrentSettings();
            SetupTabButtons();
            ApplyButton.onClick.AddListener(ApplySettings);
            BackButton.onClick.AddListener(GoBack);
        }

        private void SetupTabButtons()
        {
            for (int i = 0; i < TabButtons.Count; i++)
            {
                int index = i;
                TabButtons[i].onClick.AddListener(() => SwitchTab(index));
            }
            SwitchTab(0); // Start with the general settings tab
        }

        private void SwitchTab(int tabIndex)
        {
            GeneralSettingsTab.SetActive(tabIndex == 0);
            LLMSettingsTab.SetActive(tabIndex == 1);
            SkinSettingsTab.SetActive(tabIndex == 2);
            CardSettingsTab.SetActive(tabIndex == 3);
        }

        private void LoadCurrentSettings()
        {
            
            // Todo implement actual settings loading
            MusicVolumeSlider.value = PlayerPrefs.GetFloat(MusicVolume, 1f);
            SFXVolumeSlider.value = PlayerPrefs.GetFloat(SFXVolume, 1f);
            FullscreenToggle.isOn = Screen.fullScreen;
            PopulateResolutionDropdown();
            PopulateLLMModelDropdown();
            // todo Load skin and card settings
        }

        private void PopulateResolutionDropdown()
        {
            Resolution[] resolutions = Screen.resolutions;
            ResolutionDropdown.ClearOptions();
            List<string> options = new List<string>();

            foreach (Resolution resolution in resolutions)
            {
                string option = resolution.width + " x " + resolution.height;
                options.Add(option);
            }

            ResolutionDropdown.AddOptions(options);
            ResolutionDropdown.value = options.IndexOf(Screen.currentResolution.width + " x " + Screen.currentResolution.height);
            ResolutionDropdown.RefreshShownValue();
        }


        private void PopulateLLMModelDropdown()
        {
            LLMModelDropdown.ClearOptions();
            LLMModelDropdown.AddOptions(new List<string> { "GPT-3.5", "GPT-4", "GPT4-O","Claude","Local" });
        }

        private void ApplySettings()
        {
            PlaySelectionSound();
            PlayerPrefs.SetFloat(MusicVolume, MusicVolumeSlider.value);
            PlayerPrefs.SetFloat(SFXVolume, SFXVolumeSlider.value);
            Screen.fullScreen = FullscreenToggle.isOn;
            Resolution resolution = Screen.resolutions[ResolutionDropdown.value];
            Screen.SetResolution(resolution.width, resolution.height, Screen.fullScreen);
            PlayerPrefs.SetString(LLMModel, LLMModelDropdown.options[LLMModelDropdown.value].text);
            PlayerPrefs.Save();
        }

   
    }
}


// ---

// File: UIScreen.cs

using OcentraAI.LLMGames.ThreeCardBrag.UI;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace OcentraAI.LLMGames.Screens
{
    public abstract class UIScreen : MonoBehaviour
    {
        public GameObject Panel;
        public bool StartEnabled;
        public bool IsFocus;
        public bool Interactable;

        [SerializeField] protected CanvasGroup CanvasGroup;
        [SerializeField] protected float FadeDuration = 0.5f;

        protected virtual void Awake()
        {
            if (CanvasGroup == null)
                CanvasGroup = GetComponent<CanvasGroup>();
            if (CanvasGroup == null)
                CanvasGroup = gameObject.AddComponent<CanvasGroup>();
        }

        public virtual bool VerifyCanShow() => true;

        public virtual void OnShowScreen(bool first) { }

        public virtual void OnHideScreen(bool first) { }

        public virtual void OnScreenFocusChanged(bool focus) { }

        public virtual void OnScreenDestroy() { }

        public virtual void ResetScreenToStartState(bool cascade) { }

        public bool IsScreenInstanceVisible() => Panel.activeInHierarchy;

        protected IEnumerator FadeCoroutine(bool fadeIn)
        {
            float elapsedTime = 0;
            float startAlpha = fadeIn ? 0 : 1;
            float endAlpha = fadeIn ? 1 : 0;

            while (elapsedTime < FadeDuration)
            {
                elapsedTime += Time.deltaTime;
                CanvasGroup.alpha = Mathf.Lerp(startAlpha, endAlpha, elapsedTime / FadeDuration);
                yield return null;
            }

            CanvasGroup.alpha = endAlpha;
        }

        protected virtual void SetupBragSelectables()
        {
            if (Panel != null)
            {
                var bragSelectables = Panel.GetComponentsInChildren<BragSelectable>(true);
                foreach (var bragSelectable in bragSelectables)
                {
                    bragSelectable.ParentScreen = this;
                }
            }
        }

        public virtual void PlaySelectionSound() { }

        public virtual void PlayNavigationSound() { }

        public virtual void PlayBackGroundSound() { }

        public virtual void QuitGame()
        {
            PlaySelectionSound();
#if UNITY_EDITOR
            UnityEditor.EditorApplication.isPlaying = false;
#else
                Application.Quit();
#endif
        }

        public IEnumerator ShowScreenCoroutine()
        {
            Panel.SetActive(true);
            yield return StartCoroutine(FadeCoroutine(true));
            SetFocus(true);
            OnShowScreen(FirstShow);
            FirstShow = false;
        }

        public IEnumerator HideScreenCoroutine()
        {
            SetFocus(false);
            yield return StartCoroutine(FadeCoroutine(false));
            Panel.SetActive(false);
            OnHideScreen(FirstHide);
            FirstHide = false;
        }

        public virtual void ShowScreenInstance() { }

        public virtual void HideScreenInstance() { }

        public virtual void ToggleScreenInstance() { }

        protected static bool FirstShow = true;
        protected static bool FirstHide = true;

        public virtual void SetFocus(bool isFocus)
        {
            Interactable = isFocus;
            IsFocus = isFocus;
            OnScreenFocusChanged(isFocus);
        }
    }

    public abstract class UIScreen<T> : UIScreen where T : UIScreen
    {
        public static T Instance { get; private set; }

        private static readonly Stack<UIScreen> ScreenHistory = new Stack<UIScreen>();

        public static void DestroyScreen()
        {
            if (Instance != null)
            {
                Instance.OnScreenDestroy();
                Destroy(Instance.gameObject);
                Instance = null;
            }
        }

        public static bool IsScreenVisible() => Instance != null && Instance.Panel.activeInHierarchy;

        public override void ShowScreenInstance() => ShowScreen();

        public override void HideScreenInstance() => HideScreen();

        public override void ToggleScreenInstance() => ToggleScreen();

        public static void ShowScreen(bool condition)
        {
            if (condition != IsScreenVisible())
            {
                if (condition)
                    ShowScreen();
                else
                    HideScreen();
            }
        }

        public static void ShowScreen()
        {
            if (Instance != null && Instance.VerifyCanShow())
            {
                Instance.StartCoroutine(Instance.ShowScreenCoroutine());
                ScreenHistory.Push(Instance);
            }
        }

        public static void HideScreen()
        {
            if (Instance != null)
            {
                Instance.StartCoroutine(Instance.HideScreenCoroutine());
                ScreenHistory.Pop();
            }
        }

        public static void ToggleScreen()
        {
            if (IsScreenVisible())
                HideScreen();
            else
                ShowScreen();
        }

        public static void GoBack()
        {
            if (ScreenHistory.Count > 1)
            {
                HideScreen();
                UIScreen previousScreen = ScreenHistory.Peek();
                previousScreen.ShowScreenInstance();
            }
        }

        public override void ResetScreenToStartState(bool cascade)
        {
            FirstShow = true;
            FirstHide = true;

            if (StartEnabled)
                ShowScreen();
            else
                HideScreen();

            if (cascade)
            {
                foreach (var screen in GetComponentsInChildren<UIScreen>())
                {
                    if (screen != this)
                        screen.ResetScreenToStartState(false);
                }
            }
        }

        protected override void Awake()
        {
            base.Awake();
            if (Instance != null)
            {
                Instance.gameObject.SetActive(false);
                Destroy(Instance.gameObject);
            }

            Instance = (T)(object)this;
            SetupBragSelectables();
            Instance.ResetScreenToStartState(false);
            AwakeOverride();
        }

        protected virtual void AwakeOverride() { }
    }
}

// ---

// File: WelcomeScreen.cs

using OcentraAI.LLMGames.Extensions;
using OcentraAI.LLMGames.Scriptable.ScriptableSingletons;
using OcentraAI.LLMGames.ThreeCardBrag.Manager;
using Sirenix.OdinInspector;
using System.Collections;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace OcentraAI.LLMGames.Screens
{
    public class WelcomeScreen : UIScreen<WelcomeScreen>
    {
        [ShowInInspector,Required]
        public GameObject RulesPanel { get; private set; }

        [ShowInInspector, Required]
        public Button ShowRulesButton { get; private set; }

        [ShowInInspector, Required]
        public Button StartGameButton { get; private set; }

        [ShowInInspector, Required]
        public Button QuitGameButton { get; private set; }

        [ShowInInspector, Required]
        public TextMeshProUGUI WelcomeText { get; private set; }

        [ShowInInspector, Required]
        public TextMeshProUGUI RulesText { get; private set; }

        [ShowInInspector, Required]
        public TextMeshProUGUI DescriptionText { get; private set; }

        [ShowInInspector, Required]
        public TextMeshProUGUI TipsText { get; private set; }

        private GameInfo GameInfo { get;  set; }

        protected override void Awake()
        {
            base.Awake();
            GameInfo = GameInfo.Instance;
            InitReferences();
        }

        void OnValidate()
        {
            InitReferences();
        }

       
        private void InitReferences()
        {
            RulesPanel = transform.FindChildRecursively<Transform>(nameof(RulesPanel)).gameObject;
            ShowRulesButton = transform.FindChildRecursively<Button>(nameof(ShowRulesButton));
            StartGameButton = transform.FindChildRecursively<Button>(nameof(StartGameButton));
            QuitGameButton = transform.FindChildRecursively<Button>(nameof(QuitGameButton));
            WelcomeText = transform.FindChildRecursively<TextMeshProUGUI>(nameof(WelcomeText));
            RulesText = transform.FindChildRecursively<TextMeshProUGUI>(nameof(RulesText));
            DescriptionText = transform.FindChildRecursively<TextMeshProUGUI>(nameof(DescriptionText));
            TipsText = transform.FindChildRecursively<TextMeshProUGUI>(nameof(TipsText));
        }

        public override void OnShowScreen(bool first)
        {
            base.OnShowScreen(first);
            InitializeWelcomeScreen();
        }

        private void InitializeWelcomeScreen()
        {
            RulesPanel.SetActive(false);
            StartGameButton.interactable = true;

            WelcomeText.text = "Welcome to Three Card Brag!";
            RulesText.text = GameInfo.GameRules;
            DescriptionText.text = GameInfo.GameDescription;
            TipsText.text = GameInfo.StrategyTips;

            ShowRulesButton.onClick.AddListener(ShowRules);
            StartGameButton.onClick.AddListener(StartGame);
            QuitGameButton.onClick.AddListener(QuitGame);
        }

        private void ShowRules()
        {
            RulesPanel.SetActive(true);
            PlaySelectionSound();
        }

        private void StartGame()
        {
            PlaySelectionSound();
            StartCoroutine(StartGameCoroutine());
        }

        private IEnumerator StartGameCoroutine()
        {
            yield return StartCoroutine(HideScreenCoroutine());
            //await GameManager.Instance.StartNewGameAsync();
        }

        public override void QuitGame()
        {
            base.QuitGame();
        }

        public override void OnHideScreen(bool first)
        {
            base.OnHideScreen(first);
            RulesPanel.SetActive(false);
        }

        public override void PlaySelectionSound()
        {
            // todo: Implement  sound playing logic here
            // For example:
            // AudioManager.Instance.PlaySound("ButtonClick");
        }



        public override void PlayBackGroundSound()
        {
            // todo :Implement back sound logic here
        }
    }
}

// ---

// File: AIHelper.cs

using OcentraAI.LLMGames.Scriptable.ScriptableSingletons;
using OcentraAI.LLMGames.ThreeCardBrag.Manager;
using System;
using System.Collections.Generic;
using System.Linq;

namespace OcentraAI.LLMGames.LLMServices
{
    public class AIHelper
    {
        private GameInfo GameInfo { get; set; }
        private GameManager GameManager { get; set; }

        public AIHelper(GameInfo gameInfo, GameManager gameManager)
        {
            GameInfo = gameInfo;
            GameManager = gameManager;
        }

        public string GetSystemMessage()
        {
            return $"You are an expert AI player in a Three Card Brag game. " +
                   $"Your goal is to make the best betting decisions based on the strength of your hand, the game rules, and the behavior of the human player. " +
                   $"Game Rules: {GameInfo.GameRules}. " +
                   $"Card Rankings: {GameInfo.CardRankings}. " +
                   $"Bonus Rules: {GetBonusRules(GameInfo.BonusRules)}. " +
                   $"Strategy Tips: {GameInfo.StrategyTips}. " +
                   $"Bluffing Strategies: {BluffSetting(GameInfo.GetBluffSettingConditions())}. " +
                   $"Example Hand Descriptions: {GetExampleHandDescriptions(GameInfo.GetExampleHandOdds())}. " +
                   $"Possible Moves: {GetPossibleMoves(GameInfo.GetMoveValidityConditions())}. " +
                   $"Difficulty Levels: {GetDifficultyLevel()}";
        }

        public string GetUserPrompt()
        {
            return $"Current Hand: {GetHandDetails(GameManager)}. " +
                   $"Current Hand Value: {GameManager.ComputerPlayer.CalculateHandValue()}. " +
                   $"Current Bet: {GameManager.CurrentBet}, Pot Size: {GameManager.Pot}. " +
                   $"Your Coins: {GameManager.ComputerPlayer.Coins}, Opponent's Coins: {GameManager.HumanPlayer.Coins}. " +
                   $"Current Game State: {GetGameStateDetails(GameManager)}. " +
                   $"Move Options: {GetMoveWord()}";
        }

        private string GetBonusRules(BaseBonusRule[] rules)
        {
            string bonusRules = $"BonusRule {Environment.NewLine}";
            for (int index = 0; index < rules.Length; index++)
            {
                BaseBonusRule bonusRule = rules[index];
                bonusRules += $"bonusRule {index + 1}: {bonusRule.Description} Points {bonusRule.BonusValue} {Environment.NewLine}";
            }
            return bonusRules;
        }

        private string GetExampleHandDescriptions(Dictionary<HandType, string> exampleHandOdds)
        {
            return string.Join(Environment.NewLine, exampleHandOdds.Select(hd => $"{hd.Key}: {hd.Value}"));
        }

        private string GetPossibleMoves(Dictionary<PossibleMoves, string> moveValidityConditions)
        {
            return string.Join(Environment.NewLine, moveValidityConditions.Select(mvc => $"{mvc.Key}: {mvc.Value}"));
        }

        private string BluffSetting(Dictionary<DifficultyLevels, string> bluffSettingConditions)
        {
            return string.Join(Environment.NewLine, bluffSettingConditions.Select(mvc => $"{mvc.Key}: {mvc.Value}"));
        }

        private string GetMoveWord()
        {
            return string.Join(" or ", Enum.GetNames(typeof(PossibleMoves)));
        }

        private string GetDifficultyLevel()
        {
            return string.Join(" or ", Enum.GetNames(typeof(DifficultyLevels)));
        }

        private static string GetHandDetails(GameManager gameManager)
        {
            return string.Join(", ", gameManager.ComputerPlayer.Hand.Select((card, index) => $"Card {index + 1}: {card.Rank} of {card.Suit}"));
        }

        private static string GetGameStateDetails(GameManager gameManager)
        {
            return $"Pot: {GetPotDetails(gameManager)}{Environment.NewLine}" +
                   $"Deck: {GetDeckDetails(gameManager)}{Environment.NewLine}" +
                   $"Floor: {GetFloorDetails(gameManager)}{Environment.NewLine}" +
                   $"Players: {GetPlayerDetails(gameManager)}";
        }

        private static string GetPotDetails(GameManager gameManager)
        {
            return $"Current pot: {gameManager.Pot} coins, Current bet: {gameManager.CurrentBet} coins";
        }

        private static string GetDeckDetails(GameManager gameManager)
        {
            return $"Remaining cards in deck: {gameManager.DeckManager.RemainingCards}";
        }

        private static string GetFloorDetails(GameManager gameManager)
        {
            string floorCardDetails = gameManager.DeckManager.FloorCard != null
                ? $"{gameManager.DeckManager.FloorCard.Rank} of {gameManager.DeckManager.FloorCard.Suit}"
                : "No card";

            return $"Floor card: {floorCardDetails}, Cards in floor pile: {gameManager.DeckManager.FloorCardsCount}";
        }

        private static string GetPlayerDetails(GameManager gameManager)
        {
            return $"Human: {gameManager.HumanPlayer.Coins} coins, Computer: {gameManager.ComputerPlayer.Coins} coins, " +
                   $"Human playing blind: {!gameManager.HumanPlayer.HasSeenHand}, Computer playing blind: {!gameManager.ComputerPlayer.HasSeenHand}";
        }


        public (string systemMessage, string userPrompt) GetAIInstructions()
        {
            string systemMessage = GetSystemMessage();
            string userPrompt = GetUserPrompt();
            return (systemMessage, userPrompt);
        }

    }
}


// ---

// File: AzureOpenAIService.cs

using Newtonsoft.Json;

namespace OcentraAI.LLMGames.LLMServices
{
    public class AzureOpenAIService : BaseLLMService
    {
        public AzureOpenAIService(LLMConfig config)
            : base(config)
        {
        }

        protected override string ProcessResponse(string jsonResponse)
        {
            var response = JsonConvert.DeserializeObject<OpenAIResponse>(jsonResponse);
            return response.Choices[0].Text;
        }



    }
}

// ---

// File: BaseLLMService.cs

using Newtonsoft.Json;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.Networking;

namespace OcentraAI.LLMGames.LLMServices
{
    public abstract class BaseLLMService : ILLMService
    {
        protected string Endpoint { get; set; }
        protected string ApiKey { get; set; }
        protected string ApiUrl { get; set; }
        protected string Model { get; set; }
        protected int MaxTokens { get; set; }
        protected double Temperature { get; set; }
        protected bool Stream { get; set; }

        protected BaseLLMService(LLMConfig config)
        {
            Endpoint = config.Endpoint;
            ApiKey = config.ApiKey;
            ApiUrl = config.ApiUrl;
            Model = config.Model;
            MaxTokens = config.MaxTokens;
            Temperature = config.Temperature;
            Stream = config.Stream;
        }

        public async Task<string> GetResponseAsync(string systemMessage, string userPrompt)
        {
            try
            {
                var requestContent = GenerateRequestContent(systemMessage, userPrompt);
                var jsonData = JsonConvert.SerializeObject(requestContent);
                var webRequest = new UnityWebRequest(Endpoint + ApiUrl, "POST")
                {
                    uploadHandler = new UploadHandlerRaw(Encoding.UTF8.GetBytes(jsonData)),
                    downloadHandler = new DownloadHandlerBuffer()
                };
                webRequest.SetRequestHeader("Content-Type", "application/json");
                webRequest.SetRequestHeader("Authorization", "Bearer " + ApiKey);

                var operation = webRequest.SendWebRequest();

                while (!operation.isDone)
                {
                    await Task.Yield();
                }

                if (webRequest.result == UnityWebRequest.Result.Success)
                {
                    return ProcessResponse(webRequest.downloadHandler.text);
                }
                else
                {
                    string errorContent = webRequest.downloadHandler.text;
                    Debug.LogError($"Error calling LLM API: {webRequest.responseCode} - {webRequest.error} - {errorContent}");
                    return $"Error";
                }
            }
            catch (System.Exception ex)
            {
                Debug.LogError($"Exception occurred: {ex.Message}");
                return $"Error";
            }
        }

        protected abstract string ProcessResponse(string jsonResponse);

        protected virtual object GenerateRequestContent(string systemMessage, string userPrompt)
        {
            return new
            {
                messages = new[]
                {
                    new { role = "system", content = systemMessage},
                    new { role = "user", content = userPrompt }
                },
                temperature = Temperature,
                max_tokens = MaxTokens,
                stream = Stream
            };
        }

  
    }
}


// ---

// File: CardRanking.cs

using System;

namespace OcentraAI.LLMGames
{
    [Serializable]
    public struct CardRanking
    {
        public string CardName;
        public int Value;
    }
}

// ---

// File: Choice.cs

namespace OcentraAI.LLMGames.LLMServices
{
    public class Choice
    {
        public string Text { get; set; }
    }
}

// ---

// File: ClaudeResponse.cs

namespace OcentraAI.LLMGames.LLMServices
{
    public class ClaudeResponse
    {
        public string[] Responses { get; set; }
    }
}

// ---

// File: ClaudeService.cs

using Newtonsoft.Json;

namespace OcentraAI.LLMGames.LLMServices
{
    public class ClaudeService : BaseLLMService
    {
        public ClaudeService(LLMConfig config)
            : base(config)
        {
        }

        protected override string ProcessResponse(string jsonResponse)
        {
            var response = JsonConvert.DeserializeObject<ClaudeResponse>(jsonResponse);
            return response.Responses[0];
        }



    }
}

// ---

// File: ILLMService.cs

using System.Threading.Tasks;

namespace OcentraAI.LLMGames.LLMServices
{
    public interface ILLMService
    {
        Task<string> GetResponseAsync(string systemMessage, string userPrompt);
    }
}

// ---

// File: LLMConfig.cs

namespace OcentraAI.LLMGames.LLMServices
{
    [System.Serializable]
    public class LLMConfig
    {
        public string Endpoint;
        public string ApiKey;
        public string ApiUrl;
        public string Model;
        public int MaxTokens = 150000;
        public double Temperature =0.5;
        public bool Stream =false;
    }
}



// ---

// File: LLMManager.cs

using System.Collections.Generic;
using System;
using System.Threading.Tasks;
using OcentraAI.LLMGames.Authentication;
using OcentraAI.LLMGames.ThreeCardBrag.Manager;
using UnityEngine;

namespace OcentraAI.LLMGames.LLMServices
{
    public class LLMManager : MonoBehaviour
    {
        public static LLMManager Instance { get; private set; }

        public LLMProvider CurrentProvider = LLMProvider.AzureOpenAI;
        private ILLMService CurrentLLMService { get; set; }

        async void Awake()
        {
            if (Instance != null && Instance != this)
            {
                Destroy(gameObject);
            }
            else
            {
                Instance = this;
                DontDestroyOnLoad(gameObject);
            }

            await WaitForInitialization();
        }

        private async Task WaitForInitialization()
        {
            if (UnityServicesManager.Instance != null)
            {
                while (!UnityServicesManager.Instance.IsInitialized)
                {
                    await Task.Delay(100);
                }

                SetLLMProvider(CurrentProvider);
            }
            else
            {
                Debug.Log($"UnityServicesManager is missing!");
            }
        }

        public void SetLLMProvider(LLMProvider provider)
        {
            CurrentProvider = provider;
            SetLLMProvider(provider.ToString());
        }

        public void SetLLMProvider(string provider)
        {
            if (UnityServicesManager.Instance.ConfigManager.TryGetConfigForProvider(provider, out LLMConfig config)
                && ValidateConfig(config))
            {
                CurrentLLMService = LLMServiceFactory.CreateLLMService(config);
               // Debug.Log($"LLM Service initialized for provider {provider}");
            }
            else
            {
                Debug.LogError($"Configuration for provider {provider} not found or is invalid!");
            }
        }

        public void SetLLMProvider(LLMConfig config)
        {
            if (ValidateConfig(config))
            {
                CurrentLLMService = LLMServiceFactory.CreateLLMService(config);
                Debug.Log($"LLM Service initialized with direct config");
            }
        }

        public bool ValidateConfig(LLMConfig config)
        {
            bool isValid = true;
            string errorMessage = "LLMConfig contains null or empty fields: ";

            if (string.IsNullOrEmpty(config.Endpoint))
            {
                errorMessage += "Endpoint ";
                isValid = false;
            }
            if (string.IsNullOrEmpty(config.ApiKey))
            {
                errorMessage += "ApiKey ";
                isValid = false;
            }
            if (string.IsNullOrEmpty(config.ApiUrl))
            {
                errorMessage += "ApiUrl ";
                isValid = false;
            }
            if (string.IsNullOrEmpty(config.Model))
            {
                errorMessage += "Model ";
                isValid = false;
            }

            if (!isValid)
            {
                Debug.LogError(errorMessage);
            }

            return isValid;
        }

        public async Task<string> GetLLMResponse()
        {
            var (systemMessage, userPrompt) = GameManager.Instance.AIHelper.GetAIInstructions();
            if (CurrentLLMService == null)
            {
                Debug.LogError("LLM Service is not initialized!");
                return null;
            }

            return await CurrentLLMService.GetResponseAsync(systemMessage, userPrompt);
        }
    }
}


// ---

// File: LLMProvider.cs

namespace OcentraAI.LLMGames.LLMServices
{
    public enum LLMProvider
    {
        AzureOpenAI,
        OpenAI,
        Claude,
        LocalLLM
    }
}

// ---

// File: LLMProviderConfig.cs

using Sirenix.OdinInspector;

namespace OcentraAI.LLMGames.LLMServices
{
    [System.Serializable]
    public class LLMProviderConfig
    {
        [ShowInInspector]
        public readonly LLMProvider LLMProvider;
        public LLMConfig LLMConfig ;

        public LLMProviderConfig(LLMProvider llmProvider)
        {
            LLMProvider = llmProvider;
            LLMConfig = new LLMConfig();
        }
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType())
            {
                return false;
            }

            LLMProviderConfig other = (LLMProviderConfig)obj;
            return LLMProvider == other.LLMProvider;
        }

        public override int GetHashCode()
        {
            return LLMProvider.GetHashCode();
        }
    }
}

// ---

// File: LLMServiceFactory.cs

using System;
using UnityEngine;

namespace OcentraAI.LLMGames.LLMServices
{
    public static class LLMServiceFactory
    {
        public static ILLMService CreateLLMService(LLMConfig config)
        {
            
            switch (LLMManager.Instance.CurrentProvider)
            {
                case LLMProvider.AzureOpenAI:
                    return new AzureOpenAIService(config);
                case LLMProvider.OpenAI:
                    return new OpenAIService(config);
                case LLMProvider.Claude:
                    return new ClaudeService(config);
                case LLMProvider.LocalLLM:
                    return new LocalLLMService(config);
                default:
                    Debug.LogError("Invalid LLM provider");
                    return new AzureOpenAIService(config);
                
                
            }
        }
    }
}

// ---

// File: LocalLLMResponse.cs

namespace OcentraAI.LLMGames.LLMServices
{
    public class LocalLLMResponse
    {
        public Result Result { get; set; }
    }
}

// ---

// File: LocalLLMService.cs

using Newtonsoft.Json;

namespace OcentraAI.LLMGames.LLMServices
{
    public class LocalLLMService : BaseLLMService
    {
        public LocalLLMService(LLMConfig config)
            : base(config)
        {
        }

        protected override string ProcessResponse(string jsonResponse)
        {
            var response = JsonConvert.DeserializeObject<LocalLLMResponse>(jsonResponse);
            return response.Result.GeneratedText;
        }



    }
}


// ---

// File: OpenAIResponse.cs

namespace OcentraAI.LLMGames.LLMServices
{
    public class OpenAIResponse
    {
        public Choice[] Choices { get; set; }
    }
}

// ---

// File: OpenAIService.cs

using Newtonsoft.Json;

namespace OcentraAI.LLMGames.LLMServices
{
    public class OpenAIService : BaseLLMService
    {
        public OpenAIService(LLMConfig config)
            : base(config)
        {
        }

        protected override string ProcessResponse(string jsonResponse)
        {
            var response = JsonConvert.DeserializeObject<OpenAIResponse>(jsonResponse);
            return response.Choices[0].Text;
        }


    }
}



// ---

// File: PossibleMoves.cs

namespace OcentraAI.LLMGames
{
    public enum PossibleMoves
    {
        Fold,
        Call,
        Raise,
        Check,
        BetBlind,
        SeeHand,
        DrawFromDeck,
        PickFromFloor,
        SwapCard,
        ShowHand
    }
}

// ---

// File: Result.cs

namespace OcentraAI.LLMGames.LLMServices
{
    public class Result
    {
        public string GeneratedText { get; set; }
    }
}

// ---

// File: Card.cs

using Sirenix.OdinInspector;
using System;
using UnityEditor;
using UnityEngine;

namespace OcentraAI.LLMGames.Scriptable
{
    [CreateAssetMenu(fileName = nameof(Card), menuName = "ThreeCardBrag/Card")]
    public class Card : ScriptableObject
    {
        public Suit Suit;

        public Rank Rank;

        [Required] public Sprite Sprite;

        public int GetRankValue()
        {
            return (int)Rank;
        }

        public string GetColor()
        {
            return Suit switch
            {
                Suit.Hearts => "Red",
                Suit.Diamonds => "Red",
                Suit.Clubs => "Black",
                Suit.Spades => "Black",

                _ => throw new ArgumentOutOfRangeException()
            };
        }

        public void Init(Suit suit, Rank rank)
        {
            Suit = suit;
            Rank = rank;
            AssignSprite();
            SaveChanges();
        }

        [Button, ShowIf("@this.Sprite == null")]
        public void AssignSprite()
        {
            string formattedRank = Rank switch
            {
                Rank.A => "Ace",
                Rank.K => "King",
                Rank.Q => "Queen",
                Rank.J => "Jack",
                _ => ((int)Rank).ToString()
            };

            string path = name == "BackCard" ? $"Assets/Images/Cards/BackCard.png" : $"Assets/Images/Cards/{formattedRank}_of_{Suit}.png";
            Sprite sprite = AssetDatabase.LoadAssetAtPath<Sprite>(path);

            if (sprite != null)
            {
                Sprite = sprite;
                Debug.Log($"Assigned sprite from {path}");
                SaveChanges();
            }
            else
            {
                Debug.LogWarning($"Sprite not found at {path}");
            }
        }

        private void SaveChanges()
        {
            EditorUtility.SetDirty(this);
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
        }
    }
}

// ---

// File: CustomGlobalConfig.cs

using Sirenix.OdinInspector;
using Sirenix.Utilities;

namespace OcentraAI.LLMGames.Utilities
{
    public abstract class CustomGlobalConfig<T> : SerializedScriptableObject, ICustomGlobalConfigEvents where T : SerializedScriptableObject
    {
        private static CustomGlobalConfigAttribute configAttribute;
        private static T instance;

        public static CustomGlobalConfigAttribute ConfigAttribute
        {
            get
            {
                if (configAttribute == null)
                {
                    configAttribute = typeof(T).GetCustomAttribute<CustomGlobalConfigAttribute>() ?? new CustomGlobalConfigAttribute(TypeExtensions.GetNiceName(typeof(T)));
                }
                return configAttribute;
            }
        }
        
        public static T Instance => CustomGlobalConfigUtility<T>.GetInstance(ConfigAttribute.AssetPath);

        protected virtual void OnConfigInstanceFirstAccessed() { }

        protected virtual void OnConfigAutoCreated() { }

        void ICustomGlobalConfigEvents.OnConfigAutoCreated() => OnConfigAutoCreated();

        void ICustomGlobalConfigEvents.OnConfigInstanceFirstAccessed() => OnConfigInstanceFirstAccessed();
    }
}


// ---

// File: CustomGlobalConfigAttribute.cs

using System;
using System.ComponentModel;
using UnityEngine;

namespace OcentraAI.LLMGames.Utilities
{
    [AttributeUsage(AttributeTargets.Class)]
    public class CustomGlobalConfigAttribute : Attribute
    {
        private readonly string assetPath;


        [Obsolete("It's a bit more complicated than that as it's not always possible to know the full path, so try and make due without it if you can, only using the AssetDatabase.")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string FullPath => Application.dataPath + "/" + AssetPath;


        public string AssetPath => assetPath.Trim().TrimEnd('/', '\\').TrimStart('/', '\\').Replace('\\', '/') + "/";

        internal string AssetPathWithAssetsPrefix => AssetPath.StartsWith("Assets/") ? assetPath : "Assets/" + assetPath;

        internal string AssetPathWithoutAssetsPrefix => AssetPath.StartsWith("Assets/") ? assetPath.Substring("Assets/".Length) : assetPath;


        public string ResourcesPath
        {
            get
            {
                if (IsInResourcesFolder)
                {
                    int num = AssetPath.LastIndexOf("/resources/", StringComparison.InvariantCultureIgnoreCase);
                    if (num >= 0)
                        return AssetPath.Substring(num + "/resources/".Length);
                }
                return "";
            }
        }


        [Obsolete("This option is obsolete and will have no effect - a GlobalConfig will always have an asset generated now; use a POCO singleton or a ScriptableSingleton<T> instead. Asset-less config objects that are recreated every reload cause UnityEngine.Object leaks.", true)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public bool UseAsset { get; set; }


        public bool IsInResourcesFolder => AssetPath.Contains("/resources/", StringComparison.OrdinalIgnoreCase);

        public CustomGlobalConfigAttribute()
          : this("Assets/Resources/Global Settings")
        {
        }

        public CustomGlobalConfigAttribute(string assetPath) => this.assetPath = assetPath;
    }
}

// ---

// File: CustomGlobalConfigUtility.cs

using Sirenix.Utilities.Editor;
using System;
using System.IO;
using Sirenix.Utilities;
using UnityEditor;
using UnityEngine;

namespace OcentraAI.LLMGames.Utilities
{
    public static class CustomGlobalConfigUtility<T> where T : ScriptableObject
    {
        private static T instance;


        public static bool HasInstanceLoaded => instance != null;

        public static T GetInstance(
          string defaultAssetFolderPath,
          string defaultFileNameWithoutExtension = null)
        {
            if (instance == null)
            {
                LoadInstanceIfAssetExists(defaultAssetFolderPath, defaultFileNameWithoutExtension);
                T instance1 = instance;
                string str1 = defaultFileNameWithoutExtension ?? TypeExtensions.GetNiceName(typeof(T));
                string str2 = Application.dataPath + "/" + defaultAssetFolderPath + str1 + ".asset";
                if (instance1 == null && EditorPrefs.HasKey("PREVENT_SIRENIX_FILE_GENERATION"))
                {
                    Debug.LogWarning(defaultAssetFolderPath + str1 + ".asset was prevented from being generated because the PREVENT_SIRENIX_FILE_GENERATION key was defined in Unity's EditorPrefs.");
                    instance = ScriptableObject.CreateInstance<T>();
                    return instance;
                }
                if (instance1 == null && File.Exists(str2) && EditorSettings.serializationMode == SerializationMode.ForceText)
                {
                    if (AssetScriptGuidUtility.TryUpdateAssetScriptGuid(str2, typeof(T)))
                    {
                        Debug.Log("Could not load config asset at first, but successfully detected forced text asset serialization, and corrected the config asset m_Script guid.");
                        LoadInstanceIfAssetExists(defaultAssetFolderPath, defaultFileNameWithoutExtension);
                        instance1 = instance;
                    }
                    else
                        Debug.LogWarning("Could not load config asset, and failed to auto-correct config asset m_Script guid.");
                }
                if (instance1 == null)
                {
                    instance1 = ScriptableObject.CreateInstance<T>();
                    string path1 = defaultAssetFolderPath;
                    if (!path1.StartsWith("Assets/"))
                        path1 = "Assets/" + path1.TrimStart('/');
                    if (!Directory.Exists(path1))
                    {
                        Directory.CreateDirectory(new DirectoryInfo(path1).FullName);
                        AssetDatabase.Refresh();
                    }
                    string str3 = str1;
                    string path2 = !defaultAssetFolderPath.StartsWith("Assets/") ? "Assets/" + defaultAssetFolderPath + str3 + ".asset" : defaultAssetFolderPath + str3 + ".asset";
                    if (File.Exists(str2))
                    {
                        Debug.LogWarning("Could not load config asset of type " + str3 + " from project path '" + path2 + "', but an asset file already exists at the path, so could not create a new asset either. The config asset for '" + str3 + "' has been lost, probably due to an invalid m_Script guid. Set forced text serialization in Edit -> Project Settings -> Editor -> Asset Serialization -> Mode and trigger a script reload to allow Odin to auto-correct this.");
                    }
                    else
                    {
                        AssetDatabase.CreateAsset(instance1, path2);
                        AssetDatabase.SaveAssets();
                        instance = instance1;
                        if (instance1 is IGlobalConfigEvents globalConfigEvents)
                            globalConfigEvents.OnConfigAutoCreated();
                        EditorUtility.SetDirty(instance1);
                        AssetDatabase.SaveAssets();
                        AssetDatabase.Refresh();
                    }
                }
                instance = instance1;
                if (instance is IGlobalConfigEvents instance2)
                    instance2.OnConfigInstanceFirstAccessed();
            }
            return instance;
        }

        internal static void LoadInstanceIfAssetExists(
            string assetPath,
            string defaultFileNameWithoutExtension = null)
        {
            string str1 = defaultFileNameWithoutExtension ?? TypeExtensions.GetNiceName(typeof(T));
            if (assetPath.Contains("/resources/", StringComparison.OrdinalIgnoreCase))
            {
                string str2 = assetPath;
                int num = str2.LastIndexOf("/resources/", StringComparison.OrdinalIgnoreCase);
                if (num >= 0)
                    str2 = str2.Substring(num + "/resources/".Length);
                string str3 = str1;
                instance = Resources.Load<T>(str2 + str3);
            }
            else
            {
                string str4 = str1;
                instance = AssetDatabase.LoadAssetAtPath<T>(assetPath + str4 + ".asset");
                if (instance == null)
                    instance = AssetDatabase.LoadAssetAtPath<T>("Assets/" + assetPath + str4 + ".asset");
            }
            if (!(instance == null))
                return;
            string[] assets = AssetDatabase.FindAssets("t:" + typeof(T).Name);
            if (assets.Length == 0)
                return;
            instance = AssetDatabase.LoadAssetAtPath<T>(AssetDatabase.GUIDToAssetPath(assets[0]));
        }
    }


}


// ---

// File: ICustomGlobalConfigEvents.cs

namespace OcentraAI.LLMGames.Utilities
{
    public interface ICustomGlobalConfigEvents
    {
        void OnConfigAutoCreated();
        void OnConfigInstanceFirstAccessed();
    }
}

// ---

// File: Utility.cs

using System.Threading.Tasks;

namespace OcentraAI.LLMGames
{
    public static class Utility
    {
        public static async Task Delay(float seconds)
        {
            await Task.Delay((int)(seconds * 1000));
        }
    }
}

// ---

// File: MathematicsDrawers.cs

//-----------------------------------------------------------------------
// <copyright file="MathematicsDrawers.cs" company="Sirenix ApS">
// Copyright (c) Sirenix ApS. All rights reserved.
// </copyright>
//-----------------------------------------------------------------------

namespace Sirenix.OdinInspector.Modules.UnityMathematics.Editor
{
#if UNITY_EDITOR
    using System;
    using System.Collections.Generic;
    using System.Reflection;
    using Sirenix.OdinInspector.Editor;
    using Sirenix.Utilities;
    using Sirenix.Utilities.Editor;
    using Unity.Mathematics;
    using UnityEditor;
    using UnityEngine;

    public sealed class MatrixFloat2x2Processor : MatrixProcessor<float2x2> { }
    public sealed class MatrixFloat3x2Processor : MatrixProcessor<float3x2> { }
    public sealed class MatrixFloat4x2Processor : MatrixProcessor<float4x2> { }
    public sealed class MatrixFloat2x3Processor : MatrixProcessor<float2x3> { }
    public sealed class MatrixFloat3x3Processor : MatrixProcessor<float3x3> { }
    public sealed class MatrixFloat4x3Processor : MatrixProcessor<float4x3> { }
    public sealed class MatrixFloat2x4Processor : MatrixProcessor<float2x4> { }
    public sealed class MatrixFloat3x4Processor : MatrixProcessor<float3x4> { }
    public sealed class MatrixFloat4x4Processor : MatrixProcessor<float4x4> { }

    public sealed class MatrixDouble2x2Processor : MatrixProcessor<double2x2> { }
    public sealed class MatrixDouble3x2Processor : MatrixProcessor<double3x2> { }
    public sealed class MatrixDouble4x2Processor : MatrixProcessor<double4x2> { }
    public sealed class MatrixDouble2x3Processor : MatrixProcessor<double2x3> { }
    public sealed class MatrixDouble3x3Processor : MatrixProcessor<double3x3> { }
    public sealed class MatrixDouble4x3Processor : MatrixProcessor<double4x3> { }
    public sealed class MatrixDouble2x4Processor : MatrixProcessor<double2x4> { }
    public sealed class MatrixDouble3x4Processor : MatrixProcessor<double3x4> { }
    public sealed class MatrixDouble4x4Processor : MatrixProcessor<double4x4> { }

    public sealed class MatrixBool2x2Processor : MatrixProcessor<bool2x2> { }
    public sealed class MatrixBool3x2Processor : MatrixProcessor<bool3x2> { }
    public sealed class MatrixBool4x2Processor : MatrixProcessor<bool4x2> { }
    public sealed class MatrixBool2x3Processor : MatrixProcessor<bool2x3> { }
    public sealed class MatrixBool3x3Processor : MatrixProcessor<bool3x3> { }
    public sealed class MatrixBool4x3Processor : MatrixProcessor<bool4x3> { }
    public sealed class MatrixBool2x4Processor : MatrixProcessor<bool2x4> { }
    public sealed class MatrixBool3x4Processor : MatrixProcessor<bool3x4> { }
    public sealed class MatrixBool4x4Processor : MatrixProcessor<bool4x4> { }

    public sealed class MatrixInt2x2Processor : MatrixProcessor<int2x2> { }
    public sealed class MatrixInt3x2Processor : MatrixProcessor<int3x2> { }
    public sealed class MatrixInt4x2Processor : MatrixProcessor<int4x2> { }
    public sealed class MatrixInt2x3Processor : MatrixProcessor<int2x3> { }
    public sealed class MatrixInt3x3Processor : MatrixProcessor<int3x3> { }
    public sealed class MatrixInt4x3Processor : MatrixProcessor<int4x3> { }
    public sealed class MatrixInt2x4Processor : MatrixProcessor<int2x4> { }
    public sealed class MatrixInt3x4Processor : MatrixProcessor<int3x4> { }
    public sealed class MatrixInt4x4Processor : MatrixProcessor<int4x4> { }

    public sealed class MatrixUInt2x2Processor : MatrixProcessor<uint2x2> { }
    public sealed class MatrixUInt3x2Processor : MatrixProcessor<uint3x2> { }
    public sealed class MatrixUInt4x2Processor : MatrixProcessor<uint4x2> { }
    public sealed class MatrixUInt2x3Processor : MatrixProcessor<uint2x3> { }
    public sealed class MatrixUInt3x3Processor : MatrixProcessor<uint3x3> { }
    public sealed class MatrixUInt4x3Processor : MatrixProcessor<uint4x3> { }
    public sealed class MatrixUInt2x4Processor : MatrixProcessor<uint2x4> { }
    public sealed class MatrixUInt3x4Processor : MatrixProcessor<uint3x4> { }
    public sealed class MatrixUInt4x4Processor : MatrixProcessor<uint4x4> { }

    public sealed class DisableUnityMatrixDrawerAttribute : Attribute { }

    public abstract class MatrixProcessor<T> : OdinAttributeProcessor<T>
    {
        public override void ProcessSelfAttributes(InspectorProperty property, List<Attribute> attributes)
        {
            attributes.GetOrAddAttribute<InlinePropertyAttribute>();
            attributes.GetOrAddAttribute<DisableUnityMatrixDrawerAttribute>();
        }

        public override void ProcessChildMemberAttributes(InspectorProperty parentProperty, MemberInfo member, List<Attribute> attributes)
        {
            attributes.Add(new HideLabelAttribute());
            attributes.Add(new MatrixChildAttribute());
        }
    }

    public class DisableUnityMatrixDrawerAttributeDrawer : OdinAttributeDrawer<DisableUnityMatrixDrawerAttribute>
    {
        protected override void Initialize()
        {
            this.SkipWhenDrawing = true;
            var chain = this.Property.GetActiveDrawerChain().BakedDrawerArray;

            for (int i = 0; i < chain.Length; i++)
            {
                var type = chain[i].GetType();

                if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(UnityPropertyDrawer<,>) && type.GetGenericArguments()[0].Name == "MatrixDrawer")
                {
                    chain[i].SkipWhenDrawing = true;
                    break;
                }
            }
        }
    }

    public class MatrixChildAttribute : Attribute { }

    public class Bool2Drawer : OdinValueDrawer<bool2>
    {
        private bool isMatrixChild;

        protected override void Initialize()
        {
            this.isMatrixChild = this.Property.GetAttribute<MatrixChildAttribute>() != null;
        }

        protected override void DrawPropertyLayout(GUIContent label)
        {
            Rect labelRect;
            Rect contentRect = SirenixEditorGUI.BeginHorizontalPropertyLayout(label, out labelRect);
            {
                var showLabels = !this.isMatrixChild && SirenixEditorFields.ResponsiveVectorComponentFields && contentRect.width >= 100;

                if (label != null)
                {
                    GUILayout.Space(3); // Ugh, better than nothing
                }

                var options = GUILayoutOptions.Height(EditorGUIUtility.singleLineHeight);

                GUIHelper.PushLabelWidth(SirenixEditorFields.SingleLetterStructLabelWidth);
                EditorGUILayout.BeginVertical(options);
                this.ValueEntry.Property.Children[0].Draw(showLabels ? GUIHelper.TempContent("X") : null);
                EditorGUILayout.EndVertical();
                EditorGUILayout.BeginVertical(options);
                this.ValueEntry.Property.Children[1].Draw(showLabels ? GUIHelper.TempContent("Y") : null);
                EditorGUILayout.EndVertical();
                GUIHelper.PopLabelWidth();
            }
            SirenixEditorGUI.EndHorizontalPropertyLayout();
        }
    }

    public class Bool3Drawer : OdinValueDrawer<bool3>
    {
        private bool isMatrixChild;

        protected override void Initialize()
        {
            this.isMatrixChild = this.Property.GetAttribute<MatrixChildAttribute>() != null;
        }

        protected override void DrawPropertyLayout(GUIContent label)
        {
            Rect labelRect;
            Rect contentRect = SirenixEditorGUI.BeginHorizontalPropertyLayout(label, out labelRect);
            {
                var showLabels = !this.isMatrixChild && SirenixEditorFields.ResponsiveVectorComponentFields && contentRect.width >= 100;

                if (label != null)
                {
                    GUILayout.Space(3); // Ugh, better than nothing
                }

                var options = GUILayoutOptions.Height(EditorGUIUtility.singleLineHeight);

                GUIHelper.PushLabelWidth(SirenixEditorFields.SingleLetterStructLabelWidth);
                EditorGUILayout.BeginVertical(options);
                this.ValueEntry.Property.Children[0].Draw(showLabels ? GUIHelper.TempContent("X") : null);
                EditorGUILayout.EndVertical();
                EditorGUILayout.BeginVertical(options);
                this.ValueEntry.Property.Children[1].Draw(showLabels ? GUIHelper.TempContent("Y") : null);
                EditorGUILayout.EndVertical();
                EditorGUILayout.BeginVertical(options);
                this.ValueEntry.Property.Children[2].Draw(showLabels ? GUIHelper.TempContent("Z") : null);
                EditorGUILayout.EndVertical();
                GUIHelper.PopLabelWidth();
            }
            SirenixEditorGUI.EndHorizontalPropertyLayout();
        }
    }

    public class Bool4Drawer : OdinValueDrawer<bool4>
    {
        private bool isMatrixChild;

        protected override void Initialize()
        {
            this.isMatrixChild = this.Property.GetAttribute<MatrixChildAttribute>() != null;
        }

        protected override void DrawPropertyLayout(GUIContent label)
        {
            Rect labelRect;
            Rect contentRect = SirenixEditorGUI.BeginHorizontalPropertyLayout(label, out labelRect);
            {
                var showLabels = !this.isMatrixChild && SirenixEditorFields.ResponsiveVectorComponentFields && contentRect.width >= 100;

                if (label != null)
                {
                    GUILayout.Space(3); // Ugh, better than nothing
                }

                var options = GUILayoutOptions.Height(EditorGUIUtility.singleLineHeight);

                GUIHelper.PushLabelWidth(SirenixEditorFields.SingleLetterStructLabelWidth);
                EditorGUILayout.BeginVertical(options);
                this.ValueEntry.Property.Children[0].Draw(showLabels ? GUIHelper.TempContent("X") : null);
                EditorGUILayout.EndVertical();
                EditorGUILayout.BeginVertical(options);
                this.ValueEntry.Property.Children[1].Draw(showLabels ? GUIHelper.TempContent("Y") : null);
                EditorGUILayout.EndVertical();
                EditorGUILayout.BeginVertical(options);
                this.ValueEntry.Property.Children[2].Draw(showLabels ? GUIHelper.TempContent("Z") : null);
                EditorGUILayout.EndVertical();
                EditorGUILayout.BeginVertical(options);
                this.ValueEntry.Property.Children[3].Draw(showLabels ? GUIHelper.TempContent("W") : null);
                EditorGUILayout.EndVertical();
                GUIHelper.PopLabelWidth();
            }
            SirenixEditorGUI.EndHorizontalPropertyLayout();
        }
    }

    public class Float2Drawer : OdinValueDrawer<float2>, IDefinesGenericMenuItems
    {
        private bool isMatrixChild;

        protected override void Initialize()
        {
            this.isMatrixChild = this.Property.GetAttribute<MatrixChildAttribute>() != null;
        }

        protected override void DrawPropertyLayout(GUIContent label)
        {
            Rect labelRect;
            Rect contentRect = SirenixEditorGUI.BeginHorizontalPropertyLayout(label, out labelRect);
            {
                // Slide rect
                {
                    var val = this.ValueEntry.SmartValue;
                    EditorGUI.BeginChangeCheck();
                    var vec = SirenixEditorFields.VectorPrefixSlideRect(labelRect, new Vector2(val.x, val.y));
                    val = new float2(vec.x, vec.y);
                    if (EditorGUI.EndChangeCheck())
                    {
                        this.ValueEntry.SmartValue = val;
                    }
                }

                var showLabels = !this.isMatrixChild && SirenixEditorFields.ResponsiveVectorComponentFields && contentRect.width >= 185;
                GUIHelper.PushLabelWidth(SirenixEditorFields.SingleLetterStructLabelWidth);
                this.ValueEntry.Property.Children[0].Draw(showLabels ? GUIHelper.TempContent("X") : null);
                this.ValueEntry.Property.Children[1].Draw(showLabels ? GUIHelper.TempContent("Y") : null);
                GUIHelper.PopLabelWidth();

            }
            SirenixEditorGUI.EndHorizontalPropertyLayout();
        }

        /// <summary>
        /// Populates the generic menu for the property.
        /// </summary>
        public void PopulateGenericMenu(InspectorProperty property, GenericMenu genericMenu)
        {
            float2 value = (float2)property.ValueEntry.WeakSmartValue;
            var vec = new Vector2(value.x, value.y);

            if (genericMenu.GetItemCount() > 0)
            {
                genericMenu.AddSeparator("");
            }
            genericMenu.AddItem(new GUIContent("Normalize"), Mathf.Approximately(vec.magnitude, 1f), () => NormalizeEntries(property));
            genericMenu.AddItem(new GUIContent("Zero", "Set the vector to (0, 0)"), vec == Vector2.zero, () => SetVector(property, Vector2.zero));
            genericMenu.AddItem(new GUIContent("One", "Set the vector to (1, 1)"), vec == Vector2.one, () => SetVector(property, Vector2.one));
            genericMenu.AddSeparator("");
            genericMenu.AddItem(new GUIContent("Right", "Set the vector to (1, 0)"), vec == Vector2.right, () => SetVector(property, Vector2.right));
            genericMenu.AddItem(new GUIContent("Left", "Set the vector to (-1, 0)"), vec == Vector2.left, () => SetVector(property, Vector2.left));
            genericMenu.AddItem(new GUIContent("Up", "Set the vector to (0, 1)"), vec == Vector2.up, () => SetVector(property, Vector2.up));
            genericMenu.AddItem(new GUIContent("Down", "Set the vector to (0, -1)"), vec == Vector2.down, () => SetVector(property, Vector2.down));
        }

        private void SetVector(InspectorProperty property, Vector2 value)
        {
            property.Tree.DelayActionUntilRepaint(() =>
            {
                for (int i = 0; i < property.ValueEntry.ValueCount; i++)
                {
                    property.ValueEntry.WeakValues[i] = new float2(value.x, value.y);
                }
            });
        }

        private void NormalizeEntries(InspectorProperty property)
        {
            property.Tree.DelayActionUntilRepaint(() =>
            {
                for (int i = 0; i < property.ValueEntry.ValueCount; i++)
                {
                    property.ValueEntry.WeakValues[i] = math.normalizesafe((float2)property.ValueEntry.WeakValues[i]);
                }
            });
        }
    }

    public class Float3Drawer : OdinValueDrawer<float3>, IDefinesGenericMenuItems
    {
        private bool isMatrixChild;

        protected override void Initialize()
        {
            this.isMatrixChild = this.Property.GetAttribute<MatrixChildAttribute>() != null;
        }

        protected override void DrawPropertyLayout(GUIContent label)
        {
            Rect labelRect;
            Rect contentRect = SirenixEditorGUI.BeginHorizontalPropertyLayout(label, out labelRect);
            {
                // Slide rect
                {
                    var val = this.ValueEntry.SmartValue;
                    EditorGUI.BeginChangeCheck();
                    var vec = SirenixEditorFields.VectorPrefixSlideRect(labelRect, new Vector3(val.x, val.y, val.z));
                    val = new float3(vec.x, vec.y, vec.z);
                    if (EditorGUI.EndChangeCheck())
                    {
                        this.ValueEntry.SmartValue = val;
                    }
                }

                var showLabels = !this.isMatrixChild && SirenixEditorFields.ResponsiveVectorComponentFields && contentRect.width >= 185;
                GUIHelper.PushLabelWidth(SirenixEditorFields.SingleLetterStructLabelWidth);
                this.ValueEntry.Property.Children[0].Draw(showLabels ? GUIHelper.TempContent("X") : null);
                this.ValueEntry.Property.Children[1].Draw(showLabels ? GUIHelper.TempContent("Y") : null);
                this.ValueEntry.Property.Children[2].Draw(showLabels ? GUIHelper.TempContent("Z") : null);
                GUIHelper.PopLabelWidth();

            }
            SirenixEditorGUI.EndHorizontalPropertyLayout();
        }

        /// <summary>
        /// Populates the generic menu for the property.
        /// </summary>
        public void PopulateGenericMenu(InspectorProperty property, GenericMenu genericMenu)
        {
            float3 value = (float3)property.ValueEntry.WeakSmartValue;
            var vec = new Vector3(value.x, value.y, value.z);

            if (genericMenu.GetItemCount() > 0)
            {
                genericMenu.AddSeparator("");
            }
            genericMenu.AddItem(new GUIContent("Normalize"), Mathf.Approximately(vec.magnitude, 1f), () => NormalizeEntries(property));
            genericMenu.AddItem(new GUIContent("Zero", "Set the vector to (0, 0, 0)"), vec == Vector3.zero, () => SetVector(property, Vector3.zero));
            genericMenu.AddItem(new GUIContent("One", "Set the vector to (1, 1, 1)"), vec == Vector3.one, () => SetVector(property, Vector3.one));
            genericMenu.AddSeparator("");
            genericMenu.AddItem(new GUIContent("Right", "Set the vector to (1, 0, 0)"), vec == Vector3.right, () => SetVector(property, Vector3.right));
            genericMenu.AddItem(new GUIContent("Left", "Set the vector to (-1, 0, 0)"), vec == Vector3.left, () => SetVector(property, Vector3.left));
            genericMenu.AddItem(new GUIContent("Up", "Set the vector to (0, 1, 0)"), vec == Vector3.up, () => SetVector(property, Vector3.up));
            genericMenu.AddItem(new GUIContent("Down", "Set the vector to (0, -1, 0)"), vec == Vector3.down, () => SetVector(property, Vector3.down));
            genericMenu.AddItem(new GUIContent("Forward", "Set the vector property to (0, 0, 1)"), vec == Vector3.forward, () => SetVector(property, Vector3.forward));
            genericMenu.AddItem(new GUIContent("Back", "Set the vector property to (0, 0, -1)"), vec == Vector3.back, () => SetVector(property, Vector3.back));
        }

        private void SetVector(InspectorProperty property, Vector3 value)
        {
            property.Tree.DelayActionUntilRepaint(() =>
            {
                for (int i = 0; i < property.ValueEntry.ValueCount; i++)
                {
                    property.ValueEntry.WeakValues[i] = new float3(value.x, value.y, value.z);
                }
            });
        }

        private void NormalizeEntries(InspectorProperty property)
        {
            property.Tree.DelayActionUntilRepaint(() =>
            {
                for (int i = 0; i < property.ValueEntry.ValueCount; i++)
                {
                    property.ValueEntry.WeakValues[i] = math.normalizesafe((float3)property.ValueEntry.WeakValues[i]);
                }
            });
        }
    }

    public class Float4Drawer : OdinValueDrawer<float4>, IDefinesGenericMenuItems
    {
        private bool isMatrixChild;

        protected override void Initialize()
        {
            this.isMatrixChild = this.Property.GetAttribute<MatrixChildAttribute>() != null;
        }

        protected override void DrawPropertyLayout(GUIContent label)
        {
            Rect labelRect;
            Rect contentRect = SirenixEditorGUI.BeginHorizontalPropertyLayout(label, out labelRect);
            {
                // Slide rect
                {
                    var val = this.ValueEntry.SmartValue;
                    EditorGUI.BeginChangeCheck();
                    var vec = SirenixEditorFields.VectorPrefixSlideRect(labelRect, new Vector4(val.x, val.y, val.z, val.w));
                    val = new float4(vec.x, vec.y, vec.z, vec.w);
                    if (EditorGUI.EndChangeCheck())
                    {
                        this.ValueEntry.SmartValue = val;
                    }
                }

                var showLabels = !this.isMatrixChild && SirenixEditorFields.ResponsiveVectorComponentFields && contentRect.width >= 185;
                GUIHelper.PushLabelWidth(SirenixEditorFields.SingleLetterStructLabelWidth);
                this.ValueEntry.Property.Children[0].Draw(showLabels ? GUIHelper.TempContent("X") : null);
                this.ValueEntry.Property.Children[1].Draw(showLabels ? GUIHelper.TempContent("Y") : null);
                this.ValueEntry.Property.Children[2].Draw(showLabels ? GUIHelper.TempContent("Z") : null);
                this.ValueEntry.Property.Children[3].Draw(showLabels ? GUIHelper.TempContent("W") : null);
                GUIHelper.PopLabelWidth();

            }
            SirenixEditorGUI.EndHorizontalPropertyLayout();
        }

        /// <summary>
        /// Populates the generic menu for the property.
        /// </summary>
        public void PopulateGenericMenu(InspectorProperty property, GenericMenu genericMenu)
        {
            float4 value = (float4)property.ValueEntry.WeakSmartValue;
            var vec = new Vector4(value.x, value.y, value.z, value.w);

            if (genericMenu.GetItemCount() > 0)
            {
                genericMenu.AddSeparator("");
            }
            genericMenu.AddItem(new GUIContent("Normalize"), Mathf.Approximately(vec.magnitude, 1f), () => NormalizeEntries(property));
            genericMenu.AddItem(new GUIContent("Zero", "Set the vector to (0, 0, 0, 0)"), vec == Vector4.zero, () => SetVector(property, Vector3.zero));
            genericMenu.AddItem(new GUIContent("One", "Set the vector to (1, 1, 1, 1)"), vec == Vector4.one, () => SetVector(property, Vector4.one));
            genericMenu.AddSeparator("");
            genericMenu.AddItem(new GUIContent("Right", "Set the vector to (1, 0, 0, 0)"), (Vector3)vec == Vector3.right, () => SetVector(property, Vector3.right));
            genericMenu.AddItem(new GUIContent("Left", "Set the vector to (-1, 0, 0, 0)"), (Vector3)vec == Vector3.left, () => SetVector(property, Vector3.left));
            genericMenu.AddItem(new GUIContent("Up", "Set the vector to (0, 1, 0, 0)"), (Vector3)vec == Vector3.up, () => SetVector(property, Vector3.up));
            genericMenu.AddItem(new GUIContent("Down", "Set the vector to (0, -1, 0, 0)"), (Vector3)vec == Vector3.down, () => SetVector(property, Vector3.down));
            genericMenu.AddItem(new GUIContent("Forward", "Set the vector property to (0, 0, 1, 0)"), (Vector3)vec == Vector3.forward, () => SetVector(property, Vector3.forward));
            genericMenu.AddItem(new GUIContent("Back", "Set the vector property to (0, 0, -1, 0)"), (Vector3)vec == Vector3.back, () => SetVector(property, Vector3.back));
        }

        private void SetVector(InspectorProperty property, Vector4 value)
        {
            property.Tree.DelayActionUntilRepaint(() =>
            {
                for (int i = 0; i < property.ValueEntry.ValueCount; i++)
                {
                    property.ValueEntry.WeakValues[i] = new float4(value.x, value.y, value.z, value.w);
                }
            });
        }

        private void NormalizeEntries(InspectorProperty property)
        {
            property.Tree.DelayActionUntilRepaint(() =>
            {
                for (int i = 0; i < property.ValueEntry.ValueCount; i++)
                {
                    property.ValueEntry.WeakValues[i] = math.normalizesafe((float4)property.ValueEntry.WeakValues[i]);
                }
            });
        }
    }


    public class Double2Drawer : OdinValueDrawer<double2>, IDefinesGenericMenuItems
    {
        private bool isMatrixChild;

        protected override void Initialize()
        {
            this.isMatrixChild = this.Property.GetAttribute<MatrixChildAttribute>() != null;
        }

        protected override void DrawPropertyLayout(GUIContent label)
        {
            Rect labelRect;
            Rect contentRect = SirenixEditorGUI.BeginHorizontalPropertyLayout(label, out labelRect);
            {
                // Slide rect
                {
                    var val = this.ValueEntry.SmartValue;
                    EditorGUI.BeginChangeCheck();
                    var vec = SirenixEditorFields.VectorPrefixSlideRect(labelRect, new Vector2((float)val.x, (float)val.y));
                    val = new double2(vec.x, vec.y);
                    if (EditorGUI.EndChangeCheck())
                    {
                        this.ValueEntry.SmartValue = val;
                    }
                }

                var showLabels = !this.isMatrixChild && SirenixEditorFields.ResponsiveVectorComponentFields && contentRect.width >= 185;
                GUIHelper.PushLabelWidth(SirenixEditorFields.SingleLetterStructLabelWidth);
                this.ValueEntry.Property.Children[0].Draw(showLabels ? GUIHelper.TempContent("X") : null);
                this.ValueEntry.Property.Children[1].Draw(showLabels ? GUIHelper.TempContent("Y") : null);
                GUIHelper.PopLabelWidth();

            }
            SirenixEditorGUI.EndHorizontalPropertyLayout();
        }

        /// <summary>
        /// Populates the generic menu for the property.
        /// </summary>
        public void PopulateGenericMenu(InspectorProperty property, GenericMenu genericMenu)
        {
            double2 value = (double2)property.ValueEntry.WeakSmartValue;
            var vec = new Vector2((float)value.x, (float)value.y);

            if (genericMenu.GetItemCount() > 0)
            {
                genericMenu.AddSeparator("");
            }
            genericMenu.AddItem(new GUIContent("Normalize"), Mathf.Approximately(vec.magnitude, 1f), () => NormalizeEntries(property));
            genericMenu.AddItem(new GUIContent("Zero", "Set the vector to (0, 0)"), vec == Vector2.zero, () => SetVector(property, Vector2.zero));
            genericMenu.AddItem(new GUIContent("One", "Set the vector to (1, 1)"), vec == Vector2.one, () => SetVector(property, Vector2.one));
            genericMenu.AddSeparator("");
            genericMenu.AddItem(new GUIContent("Right", "Set the vector to (1, 0)"), vec == Vector2.right, () => SetVector(property, Vector2.right));
            genericMenu.AddItem(new GUIContent("Left", "Set the vector to (-1, 0)"), vec == Vector2.left, () => SetVector(property, Vector2.left));
            genericMenu.AddItem(new GUIContent("Up", "Set the vector to (0, 1)"), vec == Vector2.up, () => SetVector(property, Vector2.up));
            genericMenu.AddItem(new GUIContent("Down", "Set the vector to (0, -1)"), vec == Vector2.down, () => SetVector(property, Vector2.down));
        }

        private void SetVector(InspectorProperty property, Vector2 value)
        {
            property.Tree.DelayActionUntilRepaint(() =>
            {
                for (int i = 0; i < property.ValueEntry.ValueCount; i++)
                {
                    property.ValueEntry.WeakValues[i] = new double2(value.x, value.y);
                }
            });
        }

        private void NormalizeEntries(InspectorProperty property)
        {
            property.Tree.DelayActionUntilRepaint(() =>
            {
                for (int i = 0; i < property.ValueEntry.ValueCount; i++)
                {
                    property.ValueEntry.WeakValues[i] = math.normalizesafe((double2)property.ValueEntry.WeakValues[i]);
                }
            });
        }
    }

    public class Double3Drawer : OdinValueDrawer<double3>, IDefinesGenericMenuItems
    {
        private bool isMatrixChild;

        protected override void Initialize()
        {
            this.isMatrixChild = this.Property.GetAttribute<MatrixChildAttribute>() != null;
        }

        protected override void DrawPropertyLayout(GUIContent label)
        {
            Rect labelRect;
            Rect contentRect = SirenixEditorGUI.BeginHorizontalPropertyLayout(label, out labelRect);
            {
                // Slide rect
                {
                    var val = this.ValueEntry.SmartValue;
                    EditorGUI.BeginChangeCheck();
                    var vec = SirenixEditorFields.VectorPrefixSlideRect(labelRect, new Vector3((float)val.x, (float)val.y, (float)val.z));
                    val = new double3(vec.x, vec.y, vec.z);
                    if (EditorGUI.EndChangeCheck())
                    {
                        this.ValueEntry.SmartValue = val;
                    }
                }

                var showLabels = !this.isMatrixChild && SirenixEditorFields.ResponsiveVectorComponentFields && contentRect.width >= 185;
                GUIHelper.PushLabelWidth(SirenixEditorFields.SingleLetterStructLabelWidth);
                this.ValueEntry.Property.Children[0].Draw(showLabels ? GUIHelper.TempContent("X") : null);
                this.ValueEntry.Property.Children[1].Draw(showLabels ? GUIHelper.TempContent("Y") : null);
                this.ValueEntry.Property.Children[2].Draw(showLabels ? GUIHelper.TempContent("Z") : null);
                GUIHelper.PopLabelWidth();

            }
            SirenixEditorGUI.EndHorizontalPropertyLayout();
        }

        /// <summary>
        /// Populates the generic menu for the property.
        /// </summary>
        public void PopulateGenericMenu(InspectorProperty property, GenericMenu genericMenu)
        {
            double3 value = (double3)property.ValueEntry.WeakSmartValue;
            var vec = new Vector3((float)value.x, (float)value.y, (float)value.z);

            if (genericMenu.GetItemCount() > 0)
            {
                genericMenu.AddSeparator("");
            }
            genericMenu.AddItem(new GUIContent("Normalize"), Mathf.Approximately(vec.magnitude, 1f), () => NormalizeEntries(property));
            genericMenu.AddItem(new GUIContent("Zero", "Set the vector to (0, 0, 0)"), vec == Vector3.zero, () => SetVector(property, Vector3.zero));
            genericMenu.AddItem(new GUIContent("One", "Set the vector to (1, 1, 1)"), vec == Vector3.one, () => SetVector(property, Vector3.one));
            genericMenu.AddSeparator("");
            genericMenu.AddItem(new GUIContent("Right", "Set the vector to (1, 0, 0)"), vec == Vector3.right, () => SetVector(property, Vector3.right));
            genericMenu.AddItem(new GUIContent("Left", "Set the vector to (-1, 0, 0)"), vec == Vector3.left, () => SetVector(property, Vector3.left));
            genericMenu.AddItem(new GUIContent("Up", "Set the vector to (0, 1, 0)"), vec == Vector3.up, () => SetVector(property, Vector3.up));
            genericMenu.AddItem(new GUIContent("Down", "Set the vector to (0, -1, 0)"), vec == Vector3.down, () => SetVector(property, Vector3.down));
            genericMenu.AddItem(new GUIContent("Forward", "Set the vector property to (0, 0, 1)"), vec == Vector3.forward, () => SetVector(property, Vector3.forward));
            genericMenu.AddItem(new GUIContent("Back", "Set the vector property to (0, 0, -1)"), vec == Vector3.back, () => SetVector(property, Vector3.back));
        }

        private void SetVector(InspectorProperty property, Vector3 value)
        {
            property.Tree.DelayActionUntilRepaint(() =>
            {
                for (int i = 0; i < property.ValueEntry.ValueCount; i++)
                {
                    property.ValueEntry.WeakValues[i] = new double3(value.x, value.y, value.z);
                }
            });
        }

        private void NormalizeEntries(InspectorProperty property)
        {
            property.Tree.DelayActionUntilRepaint(() =>
            {
                for (int i = 0; i < property.ValueEntry.ValueCount; i++)
                {
                    property.ValueEntry.WeakValues[i] = math.normalizesafe((double3)property.ValueEntry.WeakValues[i]);
                }
            });
        }
    }

    public class Double4Drawer : OdinValueDrawer<double4>, IDefinesGenericMenuItems
    {
        private bool isMatrixChild;

        protected override void Initialize()
        {
            this.isMatrixChild = this.Property.GetAttribute<MatrixChildAttribute>() != null;
        }

        protected override void DrawPropertyLayout(GUIContent label)
        {
            Rect labelRect;
            Rect contentRect = SirenixEditorGUI.BeginHorizontalPropertyLayout(label, out labelRect);
            {
                // Slide rect
                {
                    var val = this.ValueEntry.SmartValue;
                    EditorGUI.BeginChangeCheck();
                    var vec = SirenixEditorFields.VectorPrefixSlideRect(labelRect, new Vector4((float)val.x, (float)val.y, (float)val.z, (float)val.w));
                    val = new double4(vec.x, vec.y, vec.z, vec.w);
                    if (EditorGUI.EndChangeCheck())
                    {
                        this.ValueEntry.SmartValue = val;
                    }
                }

                var showLabels = !this.isMatrixChild && SirenixEditorFields.ResponsiveVectorComponentFields && contentRect.width >= 185;
                GUIHelper.PushLabelWidth(SirenixEditorFields.SingleLetterStructLabelWidth);
                this.ValueEntry.Property.Children[0].Draw(showLabels ? GUIHelper.TempContent("X") : null);
                this.ValueEntry.Property.Children[1].Draw(showLabels ? GUIHelper.TempContent("Y") : null);
                this.ValueEntry.Property.Children[2].Draw(showLabels ? GUIHelper.TempContent("Z") : null);
                this.ValueEntry.Property.Children[3].Draw(showLabels ? GUIHelper.TempContent("W") : null);
                GUIHelper.PopLabelWidth();

            }
            SirenixEditorGUI.EndHorizontalPropertyLayout();
        }

        /// <summary>
        /// Populates the generic menu for the property.
        /// </summary>
        public void PopulateGenericMenu(InspectorProperty property, GenericMenu genericMenu)
        {
            double4 value = (double4)property.ValueEntry.WeakSmartValue;
            var vec = new Vector4((float)value.x, (float)value.y, (float)value.z, (float)value.w);

            if (genericMenu.GetItemCount() > 0)
            {
                genericMenu.AddSeparator("");
            }
            genericMenu.AddItem(new GUIContent("Normalize"), Mathf.Approximately(vec.magnitude, 1f), () => NormalizeEntries(property));
            genericMenu.AddItem(new GUIContent("Zero", "Set the vector to (0, 0, 0, 0)"), vec == Vector4.zero, () => SetVector(property, Vector3.zero));
            genericMenu.AddItem(new GUIContent("One", "Set the vector to (1, 1, 1, 1)"), vec == Vector4.one, () => SetVector(property, Vector4.one));
            genericMenu.AddSeparator("");
            genericMenu.AddItem(new GUIContent("Right", "Set the vector to (1, 0, 0, 0)"), (Vector3)vec == Vector3.right, () => SetVector(property, Vector3.right));
            genericMenu.AddItem(new GUIContent("Left", "Set the vector to (-1, 0, 0, 0)"), (Vector3)vec == Vector3.left, () => SetVector(property, Vector3.left));
            genericMenu.AddItem(new GUIContent("Up", "Set the vector to (0, 1, 0, 0)"), (Vector3)vec == Vector3.up, () => SetVector(property, Vector3.up));
            genericMenu.AddItem(new GUIContent("Down", "Set the vector to (0, -1, 0, 0)"), (Vector3)vec == Vector3.down, () => SetVector(property, Vector3.down));
            genericMenu.AddItem(new GUIContent("Forward", "Set the vector property to (0, 0, 1, 0)"), (Vector3)vec == Vector3.forward, () => SetVector(property, Vector3.forward));
            genericMenu.AddItem(new GUIContent("Back", "Set the vector property to (0, 0, -1, 0)"), (Vector3)vec == Vector3.back, () => SetVector(property, Vector3.back));
        }

        private void SetVector(InspectorProperty property, Vector4 value)
        {
            property.Tree.DelayActionUntilRepaint(() =>
            {
                for (int i = 0; i < property.ValueEntry.ValueCount; i++)
                {
                    property.ValueEntry.WeakValues[i] = new double4(value.x, value.y, value.z, value.w);
                }
            });
        }

        private void NormalizeEntries(InspectorProperty property)
        {
            property.Tree.DelayActionUntilRepaint(() =>
            {
                for (int i = 0; i < property.ValueEntry.ValueCount; i++)
                {
                    property.ValueEntry.WeakValues[i] = math.normalizesafe((double4)property.ValueEntry.WeakValues[i]);
                }
            });
        }
    }

    public class Int2Drawer : OdinValueDrawer<int2>
    {
        private bool isMatrixChild;

        protected override void Initialize()
        {
            this.isMatrixChild = this.Property.GetAttribute<MatrixChildAttribute>() != null;
        }

        protected override void DrawPropertyLayout(GUIContent label)
        {
            Rect labelRect;
            Rect contentRect = SirenixEditorGUI.BeginHorizontalPropertyLayout(label, out labelRect);
            {
                var showLabels = !this.isMatrixChild && SirenixEditorFields.ResponsiveVectorComponentFields && contentRect.width >= 185;
                GUIHelper.PushLabelWidth(SirenixEditorFields.SingleLetterStructLabelWidth);
                this.ValueEntry.Property.Children[0].Draw(showLabels ? GUIHelper.TempContent("X") : null);
                this.ValueEntry.Property.Children[1].Draw(showLabels ? GUIHelper.TempContent("Y") : null);
                GUIHelper.PopLabelWidth();

            }
            SirenixEditorGUI.EndHorizontalPropertyLayout();
        }
    }

    public class Int3Drawer : OdinValueDrawer<int3>
    {
        private bool isMatrixChild;

        protected override void Initialize()
        {
            this.isMatrixChild = this.Property.GetAttribute<MatrixChildAttribute>() != null;
        }

        protected override void DrawPropertyLayout(GUIContent label)
        {
            Rect labelRect;
            Rect contentRect = SirenixEditorGUI.BeginHorizontalPropertyLayout(label, out labelRect);
            {
                var showLabels = !this.isMatrixChild && SirenixEditorFields.ResponsiveVectorComponentFields && contentRect.width >= 185;
                GUIHelper.PushLabelWidth(SirenixEditorFields.SingleLetterStructLabelWidth);
                this.ValueEntry.Property.Children[0].Draw(showLabels ? GUIHelper.TempContent("X") : null);
                this.ValueEntry.Property.Children[1].Draw(showLabels ? GUIHelper.TempContent("Y") : null);
                this.ValueEntry.Property.Children[2].Draw(showLabels ? GUIHelper.TempContent("Z") : null);
                GUIHelper.PopLabelWidth();

            }
            SirenixEditorGUI.EndHorizontalPropertyLayout();
        }
    }

    public class Int4Drawer : OdinValueDrawer<int4>
    {
        private bool isMatrixChild;

        protected override void Initialize()
        {
            this.isMatrixChild = this.Property.GetAttribute<MatrixChildAttribute>() != null;
        }

        protected override void DrawPropertyLayout(GUIContent label)
        {
            Rect labelRect;
            Rect contentRect = SirenixEditorGUI.BeginHorizontalPropertyLayout(label, out labelRect);
            {
                var showLabels = !this.isMatrixChild && SirenixEditorFields.ResponsiveVectorComponentFields && contentRect.width >= 185;
                GUIHelper.PushLabelWidth(SirenixEditorFields.SingleLetterStructLabelWidth);
                this.ValueEntry.Property.Children[0].Draw(showLabels ? GUIHelper.TempContent("X") : null);
                this.ValueEntry.Property.Children[1].Draw(showLabels ? GUIHelper.TempContent("Y") : null);
                this.ValueEntry.Property.Children[2].Draw(showLabels ? GUIHelper.TempContent("Z") : null);
                this.ValueEntry.Property.Children[3].Draw(showLabels ? GUIHelper.TempContent("W") : null);
                GUIHelper.PopLabelWidth();

            }
            SirenixEditorGUI.EndHorizontalPropertyLayout();
        }
    }

    public class UInt2Drawer : OdinValueDrawer<uint2>
    {
        private bool isMatrixChild;

        protected override void Initialize()
        {
            this.isMatrixChild = this.Property.GetAttribute<MatrixChildAttribute>() != null;
        }

        protected override void DrawPropertyLayout(GUIContent label)
        {
            Rect labelRect;
            Rect contentRect = SirenixEditorGUI.BeginHorizontalPropertyLayout(label, out labelRect);
            {
                var showLabels = !this.isMatrixChild && SirenixEditorFields.ResponsiveVectorComponentFields && contentRect.width >= 185;
                GUIHelper.PushLabelWidth(SirenixEditorFields.SingleLetterStructLabelWidth);
                this.ValueEntry.Property.Children[0].Draw(showLabels ? GUIHelper.TempContent("X") : null);
                this.ValueEntry.Property.Children[1].Draw(showLabels ? GUIHelper.TempContent("Y") : null);
                GUIHelper.PopLabelWidth();

            }
            SirenixEditorGUI.EndHorizontalPropertyLayout();
        }
    }

    public class UInt3Drawer : OdinValueDrawer<uint3>
    {
        private bool isMatrixChild;

        protected override void Initialize()
        {
            this.isMatrixChild = this.Property.GetAttribute<MatrixChildAttribute>() != null;
        }

        protected override void DrawPropertyLayout(GUIContent label)
        {
            Rect labelRect;
            Rect contentRect = SirenixEditorGUI.BeginHorizontalPropertyLayout(label, out labelRect);
            {
                var showLabels = !this.isMatrixChild && SirenixEditorFields.ResponsiveVectorComponentFields && contentRect.width >= 185;
                GUIHelper.PushLabelWidth(SirenixEditorFields.SingleLetterStructLabelWidth);
                this.ValueEntry.Property.Children[0].Draw(showLabels ? GUIHelper.TempContent("X") : null);
                this.ValueEntry.Property.Children[1].Draw(showLabels ? GUIHelper.TempContent("Y") : null);
                this.ValueEntry.Property.Children[2].Draw(showLabels ? GUIHelper.TempContent("Z") : null);
                GUIHelper.PopLabelWidth();

            }
            SirenixEditorGUI.EndHorizontalPropertyLayout();
        }
    }

    public class UInt4Drawer : OdinValueDrawer<uint4>
    {
        private bool isMatrixChild;

        protected override void Initialize()
        {
            this.isMatrixChild = this.Property.GetAttribute<MatrixChildAttribute>() != null;
        }

        protected override void DrawPropertyLayout(GUIContent label)
        {
            Rect labelRect;
            Rect contentRect = SirenixEditorGUI.BeginHorizontalPropertyLayout(label, out labelRect);
            {
                var showLabels = !this.isMatrixChild && SirenixEditorFields.ResponsiveVectorComponentFields && contentRect.width >= 185;
                GUIHelper.PushLabelWidth(SirenixEditorFields.SingleLetterStructLabelWidth);
                this.ValueEntry.Property.Children[0].Draw(showLabels ? GUIHelper.TempContent("X") : null);
                this.ValueEntry.Property.Children[1].Draw(showLabels ? GUIHelper.TempContent("Y") : null);
                this.ValueEntry.Property.Children[2].Draw(showLabels ? GUIHelper.TempContent("Z") : null);
                this.ValueEntry.Property.Children[3].Draw(showLabels ? GUIHelper.TempContent("W") : null);
                GUIHelper.PopLabelWidth();

            }
            SirenixEditorGUI.EndHorizontalPropertyLayout();
        }
    }
#endif
}

// ---

// File: BaseBonusRule.cs

using OcentraAI.LLMGames.Scriptable;
using OcentraAI.LLMGames.ThreeCardBrag.Manager;
using System;
using System.Collections.Generic;
using System.Linq;

namespace OcentraAI.LLMGames.LLMServices
{
    [Serializable]
    public abstract class BaseBonusRule
    {
        public string Description;
        public int BonusValue;
        public Card TrumpCard;

        protected BaseBonusRule(string description, int bonusValue)
        {
            Description = description;
            BonusValue = bonusValue;
        }

        public abstract bool Evaluate(List<Card> hand);

        public virtual void GetTrumpCard()
        {
            TrumpCard = GameManager.Instance.DeckManager.TrumpCard;
        }
        protected int CalculateHandValue(List<Card> hand)
        {
            return hand.Sum(card => card.GetRankValue());
        }

        protected bool HasTrumpCard(List<Card> hand)
        {
            return hand.Any(card => card.Equals(TrumpCard));
        }

        protected Dictionary<Rank, int> GetRankCounts(List<Card> hand)
        {
            var rankCounts = new Dictionary<Rank, int>();
            foreach (var card in hand)
            {
                if (!rankCounts.TryAdd(card.Rank, 1))
                {
                    rankCounts[card.Rank]++;
                }
            }
            return rankCounts;
        }

        protected bool IsRankAdjacent(Rank rank1, Rank rank2)
        {
            return Math.Abs((int)rank1 - (int)rank2) == 1 ||
                   (rank1 == Rank.A && rank2 == Rank.Two) ||
                   (rank1 == Rank.Two && rank2 == Rank.A);
        }
        protected bool IsAscendingSequence(List<int> sortedRanks)
        {
            return (sortedRanks[1] == sortedRanks[0] + 1 && sortedRanks[2] == sortedRanks[1] + 1);
        }

        protected bool IsWraparoundSequence(List<int> sortedRanks)
        {
            return (sortedRanks[0] == 2 && sortedRanks[1] == 3 && sortedRanks[2] == 14) || // A-2-3
                   (sortedRanks[0] == 2 && sortedRanks[1] == 13 && sortedRanks[2] == 14) || // K-A-2
                   (sortedRanks[0] == 12 && sortedRanks[1] == 13 && sortedRanks[2] == 14); // Q-K-A
        }

        protected bool IsSequence(List<int> ranks)
        {
            var sortedRanks = new List<int>(ranks);
            sortedRanks.Sort();
            return IsAscendingSequence(sortedRanks) || IsWraparoundSequence(sortedRanks);
        }

        protected bool CanFormSequenceWithWild(List<int> ranks)
        {
            var sortedRanks = new List<int>(ranks);
            sortedRanks.Sort();
            return CheckWildSequence(sortedRanks) || CheckWraparoundWildSequence(sortedRanks);
        }

        protected bool CheckWildSequence(List<int> sortedRanks)
        {
            return (sortedRanks[1] == sortedRanks[0] + 1 && sortedRanks[2] <= sortedRanks[1] + 2) ||
                   (sortedRanks[1] <= sortedRanks[0] + 2 && sortedRanks[2] == sortedRanks[1] + 1);
        }

        protected bool CheckWraparoundWildSequence(List<int> sortedRanks)
        {
            return (sortedRanks[0] == 2 && sortedRanks[1] <= 4) || // x-2-3, x-2-4
                   (sortedRanks[0] == 2 && sortedRanks[2] == 14) || // 2-x-A
                   (sortedRanks[1] == 13 && sortedRanks[2] == 14) || // Q-K-x, x-K-A
                   (sortedRanks[0] == 12 && sortedRanks[2] == 14); // Q-x-A
        }

        protected int GetOptimalWildCardValue(List<int> ranks)
        {
            var sortedRanks = new List<int>(ranks);
            sortedRanks.Sort();
            if (sortedRanks[0] == 2 && sortedRanks[2] == 14) // A-2-x
            {
                return 3;
            }
            else if (sortedRanks[0] == 2 && sortedRanks[1] == 13) // K-A-2
            {
                return 14; // Ace
            }
            else if (sortedRanks[1] == 13 && sortedRanks[2] == 14) // Q-K-A
            {
                return 12; // Queen
            }
            else if (sortedRanks[1] == sortedRanks[0] + 1)
            {
                return Math.Min(sortedRanks[1] + 1, 14); // Complete the sequence at the high end, max of Ace (14)
            }
            else
            {
                return sortedRanks[0] + 1; // Complete the sequence in the middle
            }
        }
    }
}

// ---

// File: DifferentColorsSequenceRule.cs

using OcentraAI.LLMGames.Scriptable;
using OcentraAI.LLMGames.Scriptable.ScriptableSingletons;
using System;
using System.Collections.Generic;
using System.Linq;

namespace OcentraAI.LLMGames.LLMServices.Rules
{
    [Serializable]
    public class DifferentColorsSequenceRule : BaseBonusRule
    {
        public DifferentColorsSequenceRule() : base("Sequence of 3 cards of different colors with Trump Wild Card. Example: 4 of Hearts, 5 of Spades, 6 of Diamonds", 5) { }

        public override bool Evaluate(List<Card> hand)
        {
            GetTrumpCard();
            if (hand.Count != 3)
            {
                return false;
            }

            int handValue = CalculateHandValue(hand);
            bool hasTrumpCard = HasTrumpCard(hand);

            string[] colors = new string[3];
            int[] ranks = new int[3];
            bool trumpUsedAsWild = false;
            int uniqueColors = 0;

            for (int i = 0; i < hand.Count; i++)
            {
                Card card = hand[i];
                string color = card.GetColor();
                bool newColor = true;
                for (int j = 0; j < i; j++)
                {
                    if (colors[j] == color)
                    {
                        newColor = false;
                        break;
                    }
                }
                if (newColor) uniqueColors++;

                colors[i] = color;
                ranks[i] = card.GetRankValue();

                if (card.Equals(TrumpCard))
                {
                    trumpUsedAsWild = true;
                }
            }

            if (uniqueColors != 3)
            {
                return false;
            }

            bool isSequence = IsSequence(ranks.ToList());
            if (isSequence)
            {
                int bonus = CalculateBonus(hand, hasTrumpCard, trumpUsedAsWild);
                BonusValue = bonus;
            }
            else if (hasTrumpCard && CanFormSequenceWithWild(ranks.ToList()))
            {
                int wildCardValue = CalculateWildCardValue(hand, ranks);
                BonusValue = wildCardValue - handValue;
                return true;
            }

            return isSequence;
        }

        private int CalculateBonus(List<Card> hand, bool hasTrumpCard, bool trumpUsedAsWild)
        {
            int bonus = BonusValue; // Base bonus

            if (hasTrumpCard)
            {
                bonus += GameInfo.Instance.CommonBonuses.TrumpCardBonus;

                if (trumpUsedAsWild)
                {
                    bonus += GameInfo.Instance.CommonBonuses.WildCardBonus;
                }

                bool isAdjacent = false;
                bool isMiddle = false;
                for (int i = 0; i < hand.Count; i++)
                {
                    if (IsRankAdjacent(hand[i].Rank, TrumpCard.Rank))
                    {
                        isAdjacent = true;
                    }
                    if (i == 1 && hand[i].Equals(TrumpCard))
                    {
                        isMiddle = true;
                    }
                }

                if (isAdjacent)
                {
                    bonus += GameInfo.Instance.CommonBonuses.RankAdjacentBonus;
                }

                if (isMiddle)
                {
                    bonus += 5; // Additional bonus for Trump card in the middle
                }
            }

            return bonus;
        }

        private int CalculateWildCardValue(List<Card> hand, int[] ranks)
        {
            int wildCardValue = 0;
            for (int i = 0; i < hand.Count; i++)
            {
                if (!hand[i].Equals(TrumpCard))
                {
                    wildCardValue += hand[i].GetRankValue();
                }
            }
            wildCardValue += GetOptimalWildCardValue(new List<int>(ranks));

            int bonus = BonusValue; // Base bonus
            bonus += GameInfo.Instance.CommonBonuses.WildCardBonus; // Bonus for using Trump Card as wild
            bonus += GameInfo.Instance.CommonBonuses.TrumpCardBonus; // Bonus for Trump Card in hand

            return wildCardValue + bonus;
        }
    }
}

// ---

// File: DifficultyLevels.cs

namespace OcentraAI.LLMGames
{
    public enum DifficultyLevels
    {
        Easy,
        Medium,
        Hard
    }
}

// ---

// File: HandType.cs

namespace OcentraAI.LLMGames
{
    public enum HandType
    {
        StrongHand,
        MediumHand,
        WeakHand
    }

    public enum Suit
    {
        Hearts,
        Diamonds,
        Clubs,
        Spades
    }

    public enum Rank
    {
        Two = 2,
        Three,
        Four,
        Five,
        Six,
        Seven,
        Eight,
        Nine,
        Ten,
        J,  // Jack
        Q,  // Queen
        K,  // King
        A   // Ace
    }


}

// ---

// File: PairInHandRule.cs

using System;
using System.Collections.Generic;
using OcentraAI.LLMGames.Scriptable;
using OcentraAI.LLMGames.Scriptable.ScriptableSingletons;

namespace OcentraAI.LLMGames.LLMServices.Rules
{
    [Serializable]
    public class PairInHandRule : BaseBonusRule
    {
        public PairInHandRule() : base("Pair in hand with bonuses for trump card and same color. Example: 5 of Hearts, 5 of Spades, and any card", 5) { }

        public override bool Evaluate(List<Card> hand)
        {
            GetTrumpCard();

            int handValue = CalculateHandValue(hand);
            bool hasTrumpCard = HasTrumpCard(hand);
            var rankCounts = GetRankCounts(hand);
            var colorCounts = GetColorCounts(hand);

            bool hasPair = HasPair(rankCounts);
            bool hasThreeOfAKind = HasThreeOfAKind(rankCounts);

            int normalBonus = CalculateBonus(hasPair, hasThreeOfAKind, hasTrumpCard, rankCounts, colorCounts);
            int normalValue = handValue + normalBonus;

            int wildCardValue = 0;
            if (hasTrumpCard && !hasThreeOfAKind)
            {
                wildCardValue = CalculateWildCardValue(hand, rankCounts);
            }

            if (wildCardValue > normalValue)
            {
                BonusValue = wildCardValue - handValue;
            }
            else
            {
                BonusValue = normalBonus;
            }

            return hasPair || hasThreeOfAKind || (hasTrumpCard && HasSingleCard(rankCounts));
        }

        private Dictionary<string, int> GetColorCounts(List<Card> hand)
        {
            var colorCounts = new Dictionary<string, int>();
            foreach (var card in hand)
            {
                var color = card.GetColor();
                if (!colorCounts.TryAdd(color, 1))
                {
                    colorCounts[color]++;
                }
            }
            return colorCounts;
        }

        private bool HasPair(Dictionary<Rank, int> rankCounts)
        {
            foreach (var count in rankCounts.Values)
            {
                if (count == 2) return true;
            }
            return false;
        }

        private bool HasThreeOfAKind(Dictionary<Rank, int> rankCounts)
        {
            foreach (var count in rankCounts.Values)
            {
                if (count == 3) return true;
            }
            return false;
        }

        private bool HasSingleCard(Dictionary<Rank, int> rankCounts)
        {
            foreach (var count in rankCounts.Values)
            {
                if (count == 1) return true;
            }
            return false;
        }

        private int CalculateBonus(bool hasPair, bool hasThreeOfAKind, bool hasTrumpCard, Dictionary<Rank, int> rankCounts, Dictionary<string, int> colorCounts)
        {
            int bonus = 0;

            if (hasTrumpCard)
            {
                bonus += GameInfo.Instance.CommonBonuses.TrumpCardBonus;
            }

            if (hasPair || hasThreeOfAKind)
            {
                bonus += BonusValue; // Base bonus for pair

                if (hasTrumpCard && rankCounts[TrumpCard.Rank] >= 2)
                {
                    bonus += GameInfo.Instance.CommonBonuses.TrumpCardBonus;
                }

                foreach (var count in colorCounts.Values)
                {
                    if (count >= 2)
                    {
                        bonus += GameInfo.Instance.CommonBonuses.SameColorBonus;
                        break;
                    }
                }
            }

            return bonus;
        }

        private int CalculateWildCardValue(List<Card> hand, Dictionary<Rank, int> rankCounts)
        {
            int maxValue = 0;

            foreach (var rank in rankCounts.Keys)
            {
                if (rankCounts[rank] == 2)
                {
                    int threeOfAKindValue = 0;
                    foreach (var card in hand)
                    {
                        if (card.Rank == rank) threeOfAKindValue += card.GetRankValue();
                    }
                    threeOfAKindValue += TrumpCard.GetRankValue();

                    int bonus = GameInfo.Instance.GetBonusRule<ThreeOfAKindRule>().BonusValue; // Base bonus for Three of a Kind
                    bonus += GameInfo.Instance.CommonBonuses.WildCardBonus; // Bonus for using Trump Card as wild
                    if (IsRankAdjacent(rank, TrumpCard.Rank))
                    {
                        bonus += GameInfo.Instance.CommonBonuses.RankAdjacentBonus;
                    }
                    int totalValue = threeOfAKindValue + bonus;
                    if (totalValue > maxValue) maxValue = totalValue;
                }
                else if (rankCounts[rank] == 1 && rank != TrumpCard.Rank)
                {
                    int pairValue = 0;
                    string cardColor = "";
                    foreach (var card in hand)
                    {
                        if (card.Rank == rank)
                        {
                            pairValue = card.GetRankValue();
                            cardColor = card.GetColor();
                            break;
                        }
                    }
                    pairValue += TrumpCard.GetRankValue();

                    int bonus = BonusValue; // Base bonus for Pair
                    bonus += GameInfo.Instance.CommonBonuses.WildCardBonus; // Bonus for using Trump Card as wild
                    if (cardColor == TrumpCard.GetColor())
                    {
                        bonus += GameInfo.Instance.CommonBonuses.SameColorBonus; // Bonus for same color
                    }
                    int totalValue = pairValue + bonus;
                    if (totalValue > maxValue) maxValue = totalValue;
                }
            }

            return maxValue;
        }
    }
}

// ---

// File: SameColorsSequenceRule.cs

using OcentraAI.LLMGames.Scriptable;
using OcentraAI.LLMGames.Scriptable.ScriptableSingletons;
using System;
using System.Collections.Generic;

namespace OcentraAI.LLMGames.LLMServices.Rules
{
    [Serializable]
    public class SameColorsSequenceRule : BaseBonusRule
    {
        public SameColorsSequenceRule() : base("Sequence of 3 cards of the same color with Trump Wild Card. Example: 7 of Hearts, 8 of Diamonds, 9 of Hearts", 10) { }

        public override bool Evaluate(List<Card> hand)
        {
            GetTrumpCard();
            if (hand.Count != 3)
            {
                return false;
            }

            int handValue = CalculateHandValue(hand);
            bool hasTrumpCard = HasTrumpCard(hand);

            string firstCardColor = hand[0].GetColor();
            List<int> ranks = new List<int>();
            bool allSameColor = true;
            bool trumpUsedAsWild = false;

            for (int i = 0; i < hand.Count; i++)
            {
                Card card = hand[i];
                if (card.GetColor() != firstCardColor && !card.Equals(TrumpCard))
                {
                    allSameColor = false;
                    break;
                }
                if (card.Equals(TrumpCard))
                {
                    trumpUsedAsWild = true;
                }
                ranks.Add(card.GetRankValue());
            }

            if (!allSameColor)
            {
                return false;
            }

            bool isSequence = IsSequence(ranks);
            if (isSequence)
            {
                int bonus = CalculateBonus(hand, hasTrumpCard, trumpUsedAsWild);
                BonusValue = bonus;
            }
            else if (hasTrumpCard && CanFormSequenceWithWild(ranks))
            {
                int wildCardValue = CalculateWildCardValue(hand, ranks);
                BonusValue = wildCardValue - handValue;
                return true;
            }

            return isSequence;
        }

        private int CalculateBonus(List<Card> hand, bool hasTrumpCard, bool trumpUsedAsWild)
        {
            int bonus = BonusValue; // Base bonus

            if (hasTrumpCard)
            {
                bonus += GameInfo.Instance.CommonBonuses.TrumpCardBonus;

                if (trumpUsedAsWild)
                {
                    bonus += GameInfo.Instance.CommonBonuses.WildCardBonus;
                }

                bool isAdjacent = false;
                bool isMiddle = false;
                for (int i = 0; i < hand.Count; i++)
                {
                    if (IsRankAdjacent(hand[i].Rank, TrumpCard.Rank))
                    {
                        isAdjacent = true;
                    }
                    if (i == 1 && hand[i].Equals(TrumpCard))
                    {
                        isMiddle = true;
                    }
                }

                if (isAdjacent)
                {
                    bonus += GameInfo.Instance.CommonBonuses.RankAdjacentBonus;
                }

                if (isMiddle)
                {
                    bonus += 5; // Additional bonus for Trump card in the middle
                }
            }

            return bonus;
        }

        private int CalculateWildCardValue(List<Card> hand, List<int> ranks)
        {
            int wildCardValue = 0;
            for (int i = 0; i < hand.Count; i++)
            {
                if (!hand[i].Equals(TrumpCard))
                {
                    wildCardValue += hand[i].GetRankValue();
                }
            }
            wildCardValue += GetOptimalWildCardValue(ranks);

            int bonus = BonusValue; // Base bonus
            bonus += GameInfo.Instance.CommonBonuses.WildCardBonus; // Bonus for using Trump Card as wild
            bonus += GameInfo.Instance.CommonBonuses.TrumpCardBonus; // Bonus for Trump Card in hand

            return wildCardValue + bonus;
        }
    }
}

// ---

// File: StraightFlushRule.cs

using OcentraAI.LLMGames.Scriptable;
using OcentraAI.LLMGames.Scriptable.ScriptableSingletons;
using System;
using System.Collections.Generic;

namespace OcentraAI.LLMGames.LLMServices.Rules
{
    [Serializable]
    public class StraightFlushRule : BaseBonusRule
    {
        public StraightFlushRule() : base("Straight Flush with Trump Wild Card. Example: 9, 10, J of Spades", 12) { }

        public override bool Evaluate(List<Card> hand)
        {
            GetTrumpCard();
            if (hand.Count != 3)
            {
                return false;
            }

            int handValue = CalculateHandValue(hand);
            bool hasTrumpCard = HasTrumpCard(hand);

            Suit firstCardSuit = hand[0].Suit;
            List<int> ranks = new List<int>();
            bool allSameSuit = true;

            for (int i = 0; i < hand.Count; i++)
            {
                Card card = hand[i];
                if (card.Suit != firstCardSuit && !card.Equals(TrumpCard))
                {
                    allSameSuit = false;
                    break;
                }
                ranks.Add(card.GetRankValue());
            }

            if (!allSameSuit)
            {
                return false;
            }

            int normalValue = CalculateNormalValue(hand, ranks, hasTrumpCard);
            int wildCardValue = hasTrumpCard ? CalculateWildCardValue(hand, ranks) : 0;

            if (wildCardValue > normalValue)
            {
                BonusValue = wildCardValue - handValue;
            }
            else
            {
                BonusValue = normalValue - handValue;
            }

            return IsSequence(ranks) || (hasTrumpCard && CanFormSequenceWithWild(ranks));
        }

        private int CalculateNormalValue(List<Card> hand, List<int> ranks, bool hasTrumpCard)
        {
            int bonus = 0;
            if (IsSequence(ranks))
            {
                bonus += BonusValue; // Base bonus for Straight Flush

                if (hasTrumpCard)
                {
                    bonus += GameInfo.Instance.CommonBonuses.TrumpCardBonus;

                    bool isAdjacent = false;
                    for (int i = 0; i < hand.Count; i++)
                    {
                        if (IsRankAdjacent(hand[i].Rank, TrumpCard.Rank))
                        {
                            isAdjacent = true;
                            break;
                        }
                    }

                    if (isAdjacent)
                    {
                        bonus += GameInfo.Instance.CommonBonuses.RankAdjacentBonus;
                    }
                }
            }

            return CalculateHandValue(hand) + bonus;
        }

        private int CalculateWildCardValue(List<Card> hand, List<int> ranks)
        {
            if (!CanFormSequenceWithWild(ranks))
            {
                return 0;
            }

            int straightFlushValue = 0;
            for (int i = 0; i < hand.Count; i++)
            {
                if (!hand[i].Equals(TrumpCard))
                {
                    straightFlushValue += hand[i].GetRankValue();
                }
            }
            straightFlushValue += GetOptimalWildCardValue(ranks);

            int bonus = BonusValue; // Base bonus for Straight Flush
            bonus += GameInfo.Instance.CommonBonuses.WildCardBonus; // Bonus for using Trump Card as wild
            bonus += GameInfo.Instance.CommonBonuses.TrumpCardBonus; // Bonus for Trump Card in hand

            return straightFlushValue + bonus;
        }
    }
}

// ---

// File: ThreeConsecutiveSameSuitRule.cs

using OcentraAI.LLMGames.Scriptable;
using OcentraAI.LLMGames.Scriptable.ScriptableSingletons;
using System;
using System.Collections.Generic;

namespace OcentraAI.LLMGames.LLMServices.Rules
{
    [Serializable]
    public class ThreeConsecutiveSameSuitRule : BaseBonusRule
    {
        public ThreeConsecutiveSameSuitRule() : base("Sequence of 3 cards of the same suit with Trump Wild Card. Example: 4, 5, 6 of Hearts", 10) { }

        public override bool Evaluate(List<Card> hand)
        {
            GetTrumpCard();
            if (hand.Count != 3)
            {
                return false;
            }

            int handValue = CalculateHandValue(hand);
            bool hasTrumpCard = HasTrumpCard(hand);

            Suit firstCardSuit = hand[0].Suit;
            List<int> ranks = new List<int>();
            bool allSameSuit = true;
            bool trumpUsedAsWild = false;

            for (int i = 0; i < hand.Count; i++)
            {
                Card card = hand[i];
                if (card.Suit != firstCardSuit && !card.Equals(TrumpCard))
                {
                    allSameSuit = false;
                    break;
                }
                if (card.Equals(TrumpCard))
                {
                    trumpUsedAsWild = true;
                }
                ranks.Add(card.GetRankValue());
            }

            if (!allSameSuit)
            {
                return false;
            }

            bool isSequence = IsSequence(ranks);
            if (isSequence)
            {
                int bonus = CalculateBonus(hand, hasTrumpCard, trumpUsedAsWild);
                BonusValue = bonus;
            }

            return isSequence;
        }

        private int CalculateBonus(List<Card> hand, bool hasTrumpCard, bool trumpUsedAsWild)
        {
            int bonus = BonusValue; // Base bonus

            if (hasTrumpCard)
            {
                bonus += GameInfo.Instance.CommonBonuses.TrumpCardBonus;

                bool isAdjacent = false;
                for (int i = 0; i < hand.Count; i++)
                {
                    if (IsRankAdjacent(hand[i].Rank, TrumpCard.Rank))
                    {
                        isAdjacent = true;
                        break;
                    }
                }

                if (isAdjacent)
                {
                    bonus += GameInfo.Instance.CommonBonuses.RankAdjacentBonus;
                }

                if (trumpUsedAsWild)
                {
                    bonus += GameInfo.Instance.CommonBonuses.WildCardBonus;
                }
            }

            return bonus;
        }
    }
}

// ---

// File: ThreeOfAKindRule.cs

using OcentraAI.LLMGames.Scriptable;
using OcentraAI.LLMGames.Scriptable.ScriptableSingletons;
using OcentraAI.LLMGames.ThreeCardBrag.Manager;
using System;
using System.Collections.Generic;

namespace OcentraAI.LLMGames.LLMServices.Rules
{
    [Serializable]
    public class ThreeOfAKindRule : BaseBonusRule
    {
        public ThreeOfAKindRule() : base("Three of a Kind with Trump Wild Card. Example: AAA or KKK", 15) { }

        public override bool Evaluate(List<Card> hand)
        {
            GetTrumpCard();
            if (hand.Count != 3)
            {
                return false;
            }

            int handValue = CalculateHandValue(hand);
            var rankCounts = GetRankCounts(hand);
            bool hasTrumpCard = HasTrumpCard(hand);

            int normalValue = CalculateNormalValue(hand, rankCounts, hasTrumpCard);
            int wildCardValue = hasTrumpCard ? CalculateWildCardValue(hand, rankCounts) : 0;

            if (wildCardValue > normalValue)
            {
                BonusValue = wildCardValue - handValue;
            }
            else
            {
                BonusValue = normalValue - handValue;
            }

            return rankCounts.ContainsValue(3) || (hasTrumpCard && rankCounts.ContainsValue(2));
        }

        private int CalculateNormalValue(List<Card> hand, Dictionary<Rank, int> rankCounts, bool hasTrumpCard)
        {
            int bonus = 0;
            bool isThreeOfAKind = false;

            foreach (var count in rankCounts.Values)
            {
                if (count == 3)
                {
                    isThreeOfAKind = true;
                    break;
                }
            }

            if (isThreeOfAKind)
            {
                bonus += BonusValue; // Base bonus for Three of a Kind

                if (hasTrumpCard)
                {
                    bonus += GameInfo.Instance.CommonBonuses.TrumpCardBonus;

                    bool hasAdjacentRank = false;
                    for (int i = 0; i < hand.Count; i++)
                    {
                        if (IsRankAdjacent(hand[i].Rank, TrumpCard.Rank))
                        {
                            hasAdjacentRank = true;
                            break;
                        }
                    }

                    if (hasAdjacentRank)
                    {
                        bonus += GameInfo.Instance.CommonBonuses.RankAdjacentBonus;
                    }
                }
            }

            return CalculateHandValue(hand) + bonus;
        }

        private int CalculateWildCardValue(List<Card> hand, Dictionary<Rank, int> rankCounts)
        {
            int maxValue = 0;

            foreach (var kvp in rankCounts)
            {
                if (kvp.Value == 2)
                {
                    int threeOfAKindValue = 0;
                    for (int i = 0; i < hand.Count; i++)
                    {
                        if (hand[i].Rank == kvp.Key)
                        {
                            threeOfAKindValue += hand[i].GetRankValue();
                        }
                    }
                    threeOfAKindValue += TrumpCard.GetRankValue();

                    int bonus = BonusValue; // Base bonus for Three of a Kind
                    bonus += GameInfo.Instance.CommonBonuses.WildCardBonus; // Bonus for using Trump Card as wild
                    bonus += GameInfo.Instance.CommonBonuses.TrumpCardBonus; // Bonus for Trump Card in hand

                    if (IsRankAdjacent(kvp.Key, TrumpCard.Rank))
                    {
                        bonus += GameInfo.Instance.CommonBonuses.RankAdjacentBonus;
                    }

                    int totalValue = threeOfAKindValue + bonus;
                    if (totalValue > maxValue)
                    {
                        maxValue = totalValue;
                    }
                }
            }

            return maxValue;
        }
    }
}

// ---

// File: Deck.cs

using Sirenix.OdinInspector;
using System.Collections.Generic;
using System.Linq;
using OcentraAI.LLMGames.Utilities;
using UnityEditor;
using UnityEngine;
using System;

namespace OcentraAI.LLMGames.Scriptable.ScriptableSingletons
{
    [CreateAssetMenu(fileName = nameof(Deck), menuName = "ThreeCardBrag/Deck")]
    [CustomGlobalConfig("Assets/Resources/")]
    public class Deck : CustomGlobalConfig<Deck>
    {
        [ShowInInspector]
        public List<Card> CardTemplates = new List<Card>();

        [ShowInInspector, Required]
        public Card BackCard;

        [Button]
        private void LoadCardsFromResources()
        {
            var allCards = Resources.LoadAll<Card>("Cards").ToList();

            // Filter out the BackCard
            BackCard = allCards.FirstOrDefault(card => card.name == nameof(BackCard));
            CardTemplates = allCards.Where(card => card.name != nameof(BackCard)).ToList();

            if (CardTemplates.Count == 0)
            {
                Debug.LogError("No card assets found in Resources/Cards. Please ensure card assets are in the correct location.");
                CreateAllCards();
            }
            else if (ValidateDeck() == false)
            {
                CreateMissingCards();
            }

            SaveChanges();
        }

        [Button]
        private bool ValidateDeck()
        {
            if (CardTemplates.Count != 52) 
            {
                Debug.LogError($"Invalid number of cards in the deck. Expected 52, but found {CardTemplates.Count}");
                return false;
            }


            foreach (Suit suit in Enum.GetValues(typeof(Suit)))
            {
                foreach (Rank rank in Enum.GetValues(typeof(Rank)))
                {
                    if (!CardTemplates.Any(card => card.Suit == suit && card.Rank == rank))
                    {
                        Debug.LogError($"Missing card: {rank} of {suit}");
                        return false;
                    }
                }
            }


            var cardGroups = CardTemplates.GroupBy(card => new { suit = card.Suit, rank = card.Rank });
            foreach (var group in cardGroups)
            {
                if (group.Count() > 1)
                {
                    Debug.LogError($"Duplicate card found: {group.Key.rank} of {group.Key.suit}");
                    return false;
                }
            }

            return true;
        }

        private void CreateMissingCards()
        {

            foreach (Suit suit in Enum.GetValues(typeof(Suit)))
            {
                foreach (Rank rank in Enum.GetValues(typeof(Rank)))
                {
                    Card existingCard = CardTemplates.FirstOrDefault(card => card.Suit == suit && card.Rank == rank);
                    if (existingCard == null)
                    {
                        CreateCard(suit, rank);
                    }
                    else if (existingCard.Sprite == null)
                    {
                        existingCard.AssignSprite();
                    }
                }
            }


            SaveChanges();
        }

        private void CreateAllCards()
        {

            foreach (Suit suit in Enum.GetValues(typeof(Suit)))
            {
                foreach (Rank rank in Enum.GetValues(typeof(Rank)))
                {
                    CreateCard(suit, rank);
                }
            }

            SaveChanges();
        }


        private void CreateCard(Suit suit, Rank rank)
        {
            Card newCard = CreateInstance<Card>();
            newCard.Init(suit, rank);
            string path = $"Assets/Resources/Cards/{rank.ToString()}_of_{suit.ToString()}.asset";
            AssetDatabase.CreateAsset(newCard, path);
            CardTemplates.Add(newCard);
            Debug.Log($"Created card: {rank.ToString()} of {suit.ToString()} at {path}");
        }

        private void SaveChanges()
        {
#if UNITY_EDITOR

            EditorUtility.SetDirty(this);
            if (BackCard != null)
            {
                EditorUtility.SetDirty(BackCard);
            }
            foreach (var card in CardTemplates)
            {
                EditorUtility.SetDirty(card);
            }
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
#endif
        }
    }
}


// ---

// File: GameInfo.cs

using UnityEngine;
using System;
using System.Collections.Generic;
using OcentraAI.LLMGames.LLMServices;
using OcentraAI.LLMGames.LLMServices.Rules;
using OcentraAI.LLMGames.Utilities;
using Sirenix.OdinInspector;
using Sirenix.Serialization;
using System.Linq;


#if UNITY_EDITOR
using UnityEditor;
#endif

namespace OcentraAI.LLMGames.Scriptable.ScriptableSingletons
{
    [CreateAssetMenu(fileName = nameof(GameInfo), menuName = "ThreeCardBrag/GameInfo")]
    [CustomGlobalConfig("Assets/Resources/")]
    public class GameInfo : CustomGlobalConfig<GameInfo>
    {
        [TextArea(10, 20)]
        public string GameRules;

        [TextArea(5, 10)]
        public string GameDescription;

        [TextArea(5, 10)]
        public string StrategyTips;

        [OdinSerialize, ShowInInspector]
        private Dictionary<PossibleMoves, string> moveValidityConditions = new Dictionary<PossibleMoves, string>();

        [OdinSerialize, ShowInInspector]
        private Dictionary<DifficultyLevels, string> bluffSettingConditions = new Dictionary<DifficultyLevels, string>();

        [OdinSerialize, ShowInInspector]
        private Dictionary<HandType, string> exampleHandOdds = new Dictionary<HandType, string>();

        [OdinSerialize, ShowInInspector]
        public BaseBonusRule[] BonusRules;

        [ShowInInspector]
        public CardRanking[] CardRankings;

        [ShowInInspector]
        public BonusValues CommonBonuses;

        [Button(ButtonSizes.Small)]
        public void InitializeGameInfo()
        {
            InitializeBonusRules();
            InitializeGameRules();
            InitializeGameDescription();
            InitializeStrategyTips();
            InitializeCardRankings();
            InitializeMoveValidityConditions();
            InitializeBluffSettingConditions();
            InitializeExampleHandOdds();
            SaveChanges();
        }

        private void InitializeCommonBonuses()
        {
            CommonBonuses = new BonusValues
            {
                TrumpCardBonus = 5,
                SameColorBonus = 5,
                WildCardBonus = 5,
                RankAdjacentBonus = 5
            };
        }

        private void InitializeBonusRules()
        {
            InitializeCommonBonuses();

            BonusRules = new BaseBonusRule[]
            {
                new StraightFlushRule(),
                new DifferentColorsSequenceRule(),
                new PairInHandRule(),
                new ThreeConsecutiveSameSuitRule(),
                new ThreeOfAKindRule(),
                new SameColorsSequenceRule(),
                
            };
        }



        private void InitializeGameRules()
        {
            GameRules = $"Three Card Brag Rules:{Environment.NewLine}{Environment.NewLine}" +
                $"1. Each player is dealt 3 cards at the start of each round.{Environment.NewLine}" +
                $"2. Players can bet blind or see their hand.{Environment.NewLine}" +
                $"3. Blind betting doubles the current bet.{Environment.NewLine}" +
                $"4. Players who have seen their hand bet double the current bet.{Environment.NewLine}" +
                $"5. Players can draw a new card to the floor.{Environment.NewLine}" +
                $"6. Players can pick and swap a card from the floor.{Environment.NewLine}" +
                $"7. Players can fold, call, or raise.{Environment.NewLine}" +
                $"8. Highest hand value wins (Ace high).{Environment.NewLine}" +
                $"9. In case of a tie, the highest card wins.{Environment.NewLine}" +
                $"10. The game ends when a player runs out of coins or after a set number of rounds.{Environment.NewLine}" +
                $"11. The trailing player can continue if they have more coins.{Environment.NewLine}" +
                $"12. Players start with 1000 coins.{Environment.NewLine}";
        }

        private void InitializeGameDescription()
        {
            GameDescription = $"Three Card Brag is an exciting card game that combines elements of poker and bluffing.{Environment.NewLine}" +
                              $"Players aim to make the best three-card hand while betting and bluffing their way to victory.{Environment.NewLine}" +
                              "Most interesting part is we will be playing against Large language model LLM i.e Chat GPT ";
        }

        private void InitializeStrategyTips()
        {
            StrategyTips = $"- Pay attention to your opponents' betting patterns.{Environment.NewLine}" +
                $"Use the blind betting option strategically to bluff or build the pot.{Environment.NewLine}" +
                $"Consider the odds of improving your hand when deciding to draw or swap cards.{Environment.NewLine}" +
                $"Don't be afraid to fold if you have a weak hand and the bets are high.{Environment.NewLine}" +
                $"Manage your coins wisely to stay in the game for multiple rounds.";
        }

        private void InitializeCardRankings()
        {
            CardRankings = new CardRanking[]
            {
                new CardRanking { CardName = "Ace", Value = 14 },
                new CardRanking { CardName = "King", Value = 13 },
                new CardRanking { CardName = "Queen", Value = 12 },
                new CardRanking { CardName = "Jack", Value = 11 },
                new CardRanking { CardName = "10", Value = 10 },
                new CardRanking { CardName = "9", Value = 9 },
                new CardRanking { CardName = "8", Value = 8 },
                new CardRanking { CardName = "7", Value = 7 },
                new CardRanking { CardName = "6", Value = 6 },
                new CardRanking { CardName = "5", Value = 5 },
                new CardRanking { CardName = "4", Value = 4 },
                new CardRanking { CardName = "3", Value = 3 },
                new CardRanking { CardName = "2", Value = 2 }
            };
        }

        private void InitializeMoveValidityConditions()
        {
            moveValidityConditions = new Dictionary<PossibleMoves, string>
            {
                { PossibleMoves.Fold, "Always valid" },
                { PossibleMoves.Call, "Valid when there's a bet to call" },
                { PossibleMoves.Raise, "Valid when you have enough coins to raise" },
                { PossibleMoves.Check, "Valid when there's no bet to call" },
                { PossibleMoves.BetBlind, "Valid only if you haven't seen your hand" },
                { PossibleMoves.SeeHand, "Valid only if you haven't seen your hand" },
                { PossibleMoves.DrawFromDeck, "Valid when there's no floor card" },
                { PossibleMoves.PickFromFloor, "Valid when there's a floor card" },
                { PossibleMoves.SwapCard, "Valid after drawing or picking from floor" },
                { PossibleMoves.ShowHand, "Valid at any time, ends the round" }
            };
        }

        private void InitializeBluffSettingConditions()
        {
            bluffSettingConditions = new Dictionary<DifficultyLevels, string>
            {
                { DifficultyLevels.Easy, "Rarely bluff" },
                { DifficultyLevels.Medium, "Occasionally bluff when the pot odds are favorable" },
                { DifficultyLevels.Hard, "Frequently bluff and try to read opponent's patterns" },
            };
        }

        private void InitializeExampleHandOdds()
        {
            exampleHandOdds = new Dictionary<HandType, string>
            {
                { HandType.StrongHand, "Three of a Kind, Straight Flush" },
                { HandType.MediumHand, "Pair or Flush" },
                { HandType.WeakHand, "High Card or No Bonus" }
            };
        }

        public Dictionary<DifficultyLevels, string> GetBluffSettingConditions()
        {
            return bluffSettingConditions;
        }

        public Dictionary<HandType, string> GetExampleHandOdds()
        {
            return exampleHandOdds;
        }

        public Dictionary<PossibleMoves, string> GetMoveValidityConditions()
        {
            return moveValidityConditions;
        }

        public T GetBonusRule<T>() where T : BaseBonusRule
        {
            return BonusRules.OfType<T>().FirstOrDefault();
        }

        private void SaveChanges()
        {
#if UNITY_EDITOR
            EditorUtility.SetDirty(this);
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
#endif

        }
    }

    [Serializable]
    public struct BonusValues
    {
        public int TrumpCardBonus;
        public int SameColorBonus;
        public int WildCardBonus;
        public int RankAdjacentBonus;
    }
}


// ---

// File: DeckManager.cs

using OcentraAI.LLMGames.Scriptable;
using OcentraAI.LLMGames.Scriptable.ScriptableSingletons;
using Sirenix.OdinInspector;
using System.Collections.Generic;
using UnityEngine;

namespace OcentraAI.LLMGames.ThreeCardBrag.Manager
{

    public class DeckManager
    {
        [ShowInInspector]
        public List<Card> DeckCards { get; private set; } = new List<Card>();

        [ShowInInspector]
        public List<Card> FloorCards { get; private set; } = new List<Card>();

        [ShowInInspector]
        public Card BackCard => Deck.Instance.BackCard;

        [ShowInInspector]
        public int TotalCards => Deck.Instance.CardTemplates.Count;
        [ShowInInspector]
        public int RemainingCards => DeckCards.Count;

        [ShowInInspector]
        public int FloorCardsCount => FloorCards.Count;

        [ShowInInspector]
        public Card FloorCard { get; private set; }

        [ShowInInspector]
        public Card SwapCard { get; private set; }

        [ShowInInspector]
        public Card TrumpCard { get; private set; }

        [ShowInInspector]
        private Queue<Card> LastDrawnTrumpCards { get; set; } = new Queue<Card>();
        public DeckManager()
        {
            InitializeDeck();
        }



        public void SetFloorCard(Card card)
        {
            FloorCard = card;
        }

        public void InitializeDeck()
        {
            DeckCards = new List<Card>(Deck.Instance.CardTemplates);
            FloorCards.Clear();
            Shuffle();
        }

        public void Shuffle()
        {
            for (int i = 0; i < DeckCards.Count; i++)
            {
                Card temp = DeckCards[i];
                int randomIndex = Random.Range(i, DeckCards.Count);
                DeckCards[i] = DeckCards[randomIndex];
                DeckCards[randomIndex] = temp;
            }
        }

        public Card DrawCard()
        {
            if (DeckCards.Count == 0) return null;
            Shuffle();
            Card card = DeckCards[0];
            DeckCards.RemoveAt(0);
            return card;
        }

        public void AddToFloorCardList(Card card)
        {
            if (!FloorCards.Contains(card))
            {
                FloorCards.Add(card);
                GameManager.Instance.UIController.UpdateFloorCards(card);

            }

        }

        public void SetRandomTrumpCard()
        {
            List<Card> cards = new List<Card>(Deck.Instance.CardTemplates);

            if (cards.Count == 0) return;

            Card trumpCard = null;
            bool validCardFound = false;
            while (!validCardFound)
            {
                int randomIndex = Random.Range(0, cards.Count);
                trumpCard = cards[randomIndex];

                if (!LastDrawnTrumpCards.Contains(trumpCard))
                {
                    validCardFound = true;
                    TrumpCard = trumpCard;
                }
            }

            LastDrawnTrumpCards.Enqueue(trumpCard);

            if (LastDrawnTrumpCards.Count > 10)
            {
                LastDrawnTrumpCards.Dequeue();
            }
        }


        public void ResetForNewGame()
        {
            Reset();
            LastDrawnTrumpCards = new Queue<Card>();

        }

        public void Reset()
        {
            InitializeDeck();

        }

        public void SetSwapCard(Card card)
        {
            SwapCard = card;
        }
    }
}

// ---

// File: GameManager.cs

using System;
using System.Threading;
using System.Threading.Tasks;
using UnityEngine;
using OcentraAI.LLMGames.LLMServices;
using OcentraAI.LLMGames.ThreeCardBrag.Players;
using OcentraAI.LLMGames.ThreeCardBrag.UI.Controllers;
using OcentraAI.LLMGames.ThreeCardBrag.Scores;
using Sirenix.OdinInspector;
using OcentraAI.LLMGames.Scriptable.ScriptableSingletons;

namespace OcentraAI.LLMGames.ThreeCardBrag.Manager
{
    [RequireComponent(typeof(LLMManager))]
    public class GameManager : MonoBehaviour
    {
        public static GameManager Instance { get; private set; }

        [ShowInInspector]
        public HumanPlayer HumanPlayer { get; private set; }

        [ShowInInspector]
        public ComputerPlayer ComputerPlayer { get; private set; }

        [ShowInInspector]
        public UIController UIController { get; private set; }

        [ShowInInspector, ReadOnly]
        public ScoreKeeper ScoreKeeper { get; private set; }

        public float TurnDuration = 15f;

        [ShowInInspector, ReadOnly]
        public int Pot { get; private set; } = 0;

        [ShowInInspector]
        public int BaseBet { get; private set; } = 10;

        [ShowInInspector, ReadOnly]
        public int CurrentBet { get; private set; }

        [ShowInInspector, ReadOnly]
        public int BlindMultiplier { get; private set; } = 1;

        [ShowInInspector]
        public int InitialCoins { get; private set; } = 1000;

        [ShowInInspector, ReadOnly]
        private int CurrentRound { get; set; } = 0;

        [ShowInInspector, ReadOnly]
        public DeckManager DeckManager { get; private set; }

        [ShowInInspector]
        public int MaxRounds { get; private set; } = 10;

        [ShowInInspector]
        public TurnInfo CurrentTurn { get; private set; }

        public AIHelper AIHelper { get; private set; }

        public GameState CurrentGameState { get; private set; }

        public delegate void GameEventHandler(string eventDescription, GameState neState);
        public event GameEventHandler OnGameEvent;

        private void Awake()
        {
            if (Instance == null)
            {
                Instance = this;
                DontDestroyOnLoad(gameObject);
            }
            else
            {
                Destroy(gameObject);
            }
        }

        private async void Start()
        {
            await InitializeGameAsync();
        }

        private async Task InitializeGameAsync()
        {
            RaiseGameEvent("Initializing game", GameState.Initializing);
            Init();
            await Task.WhenAll(
                InitializePlayers(),
                InitializeUI(),
                InitializeDeck(),
                UIController.InitializePlayers()

            );
            await StartNewGameAsync();
        }

        private void Init()
        {
            UIController = FindObjectOfType<UIController>();
            ScoreKeeper = new ScoreKeeper();
            AIHelper = new AIHelper(GameInfo.Instance, this);
        }

        private Task InitializePlayers()
        {
            HumanPlayer = new HumanPlayer();
            HumanPlayer.SetName(nameof(HumanPlayer));
            HumanPlayer.OnActionTaken += async (action) => await HandlePlayerAction(action);

            ComputerPlayer = new ComputerPlayer();
            ComputerPlayer.SetName(nameof(ComputerPlayer));
            ComputerPlayer.OnActionTaken += async (action) => await HandlePlayerAction(action);

            HumanPlayer.OnCoinsChanged += () => UIController.UpdateCoinsDisplay();
            ComputerPlayer.OnCoinsChanged += () => UIController.UpdateCoinsDisplay();


            return Task.CompletedTask;
        }



        private void RaiseGameEvent(string eventDescription, GameState newState, bool log = false)
        {
            CurrentGameState = newState;
            if (log)
            {
                Debug.Log($"Game Event: {eventDescription} Game State changed to: {newState}");

            }
            OnGameEvent?.Invoke(eventDescription, newState);
        }

        private Task InitializeUI()
        {
            UIController = FindObjectOfType<UIController>();
            return Task.CompletedTask;
        }

        private Task InitializeDeck()
        {
            DeckManager = new DeckManager();
            return Task.CompletedTask;
        }

        public async Task StartNewGameAsync()
        {
            RaiseGameEvent("Starting a new game", GameState.StartNewGame);

            CurrentRound = 0;
            HumanPlayer.AdjustCoins(InitialCoins);
            ComputerPlayer.AdjustCoins(InitialCoins);
            await StartNewRoundAsync();
            DeckManager.ResetForNewGame();
        }

        private async Task StartNewRoundAsync()
        {
            RaiseGameEvent("Starting a New Round", GameState.StartNewRound);

            CurrentRound++;
            DeckManager.Reset();
            HumanPlayer.ResetForNewRound();
            ComputerPlayer.ResetForNewRound();
            Pot = 0;
            CurrentBet = BaseBet;
            BlindMultiplier = 1;

            for (int i = 0; i < 3; i++)
            {
                HumanPlayer.Hand.Add(DeckManager.DrawCard());
                ComputerPlayer.Hand.Add(DeckManager.DrawCard());
            }

            DeckManager.SetRandomTrumpCard();

            UpdateGameState();
            await PlayerTurnAsync(HumanPlayer);
        }

        private async Task PlayerTurnAsync(Player currentPlayer)
        {
            CurrentTurn = new TurnInfo(currentPlayer);
            Debug.Log($"PlayerTurnAsync started for: {currentPlayer.PlayerName}");

            RaiseGameEvent($"{CurrentTurn.CurrentPlayer.PlayerName}'s turn started", GameState.WaitingForPlayerAction);

            UIController.StartTurnCountdown();
            UIController.EnablePlayerActions();

            if (CurrentTurn.CurrentPlayer is HumanPlayer)
            {
                await WaitForPlayerActionAndSwitchTurnAsync();
            }
            else
            {
                await ComputerTurnAsync();
                await WaitForPlayerActionAndSwitchTurnAsync();


            }

        }

        private async Task WaitForPlayerActionAndSwitchTurnAsync()
        {
            using (CancellationTokenSource cts = new CancellationTokenSource())
            {
                Task playerActionTask = UIController.WaitForActionAsync();
                Task<bool> timerTask = UIController.CurrentPlayerTimer.WaitForCompletion();

                Task completedTask = await Task.WhenAny(playerActionTask, timerTask);
                if (completedTask == playerActionTask)
                {
                    UIController.CurrentPlayerTimer.StopTimer();
                    SwitchTurn();

                    cts.Cancel();
                }
                else
                {
                    if (await timerTask)
                    {
                        UIController.ShowMessage("Time's up! Turn is passed to the opponent.", 5f);

                    }
                    UIController.CurrentPlayerTimer.StopTimer();
                    SwitchTurn();
                }
            }
        }



        private async Task ComputerTurnAsync()
        {
            ComputerPlayer.MakeDecision(CurrentBet);
            await Task.Delay(TimeSpan.FromSeconds(UnityEngine.Random.Range(1f, 3f)));
        }

        public async Task HandlePlayerAction(PlayerAction action)
        {
            Debug.Log($"HandlePlayerAction: {action} by {CurrentTurn.CurrentPlayer.PlayerName}");
            await ProcessPlayerAction(action);
            UpdateGameState();

            if (action != PlayerAction.Fold && action != PlayerAction.Show)
            {
                Debug.Log($"Switching turn to: {CurrentTurn.CurrentPlayer.PlayerName}");
                
            }
        }

        private async Task ProcessPlayerAction(PlayerAction action)
        {
            RaiseGameEvent($"{CurrentTurn.CurrentPlayer.PlayerName} performing action: {action}", GameState.ProcessingAction);
            switch (action)
            {
                case PlayerAction.SeeHand:
                    CurrentTurn.CurrentPlayer.SeeHand();
                    UIController.EnablePlayerActions();
                    UIController.UpdateHumanPlayerHandDisplay();
                    await WaitForTurnCompletion();
                    break;
                case PlayerAction.PlayBlind:
                    PlayBlind();
                    break;
                case PlayerAction.Bet:
                case PlayerAction.Call:
                    Call();
                    break;
                case PlayerAction.Raise:
                    Raise();
                    break;
                case PlayerAction.Fold:
                    Fold();
                    break;
                case PlayerAction.DrawFromDeck:
                    CurrentTurn.CurrentPlayer.DrawFromDeck();
                    await WaitForTurnCompletion();
                    break;
                case PlayerAction.PickAndSwap:
                    CurrentTurn.CurrentPlayer.PickAndSwap();
                    break;
                case PlayerAction.Show:
                    Show();
                    break;
            }

            RaiseGameEvent($"Finished processing action: {action}", GameState.WaitingForPlayerAction);
        }

        private void UpdateGameState()
        {
            UIController.UpdateGameState();
        }

        public async Task WaitForTurnCompletion()
        {
            await CurrentTurn.TurnCompletionSource.Task;
        }

        private void PlayBlind()
        {
            CurrentBet *= BlindMultiplier;
            RaiseGameEvent($"{CurrentTurn.CurrentPlayer.PlayerName} is playing blind CurrentBet {CurrentBet}", GameState.ProcessingAction);
            if (CurrentTurn.CurrentPlayer.Coins >= CurrentBet)
            {
                CurrentTurn.CurrentPlayer.BetOnBlind();
                Pot += CurrentBet;
                BlindMultiplier *= 2;
            }
            else
            {
                UIController.ShowMessage($"Not enough coins ({CurrentTurn.CurrentPlayer.Coins}). Current bet is {CurrentBet}. You need to fold!", 5f);
            }
        }

        private void Call()
        {
            int betAmount = CurrentTurn.CurrentPlayer.HasSeenHand ? CurrentBet * 2 : CurrentBet;
            RaiseGameEvent($"{CurrentTurn.CurrentPlayer.PlayerName} is calling betAmount {betAmount}", GameState.ProcessingAction);
            if (CurrentTurn.CurrentPlayer.Coins >= betAmount)
            {
                CurrentTurn.CurrentPlayer.Bet();
                Pot += betAmount;
            }
            else
            {
                UIController.ShowMessage($"Not enough coins ({CurrentTurn.CurrentPlayer.Coins}). Current bet is {CurrentBet}. You need to fold!", 5f);
            }
        }

        private void Raise()
        {
            RaiseGameEvent($"{CurrentTurn.CurrentPlayer.PlayerName} is folding", GameState.ProcessingAction);
            if (CurrentTurn.CurrentPlayer.Coins >= CurrentBet)
            {
                CurrentTurn.CurrentPlayer.Raise();
                Pot += CurrentBet;
            }
            else
            {
                UIController.ShowMessage($"Not enough coins ({CurrentTurn.CurrentPlayer.Coins}). Current bet is {CurrentBet}. You need to fold!", 5f);
            }
        }

        private void Fold()
        {
            RaiseGameEvent($"Player {CurrentTurn.CurrentPlayer} is Folding their hands", GameState.ProcessingAction);
            CurrentTurn.CurrentPlayer.Fold();
            EndRound(GetOtherPlayer(CurrentTurn.CurrentPlayer));
        }

        private void Show()
        {
            RaiseGameEvent("Players are showing their hands", GameState.ProcessingAction);
            HumanPlayer.ShowHand(true);
            ComputerPlayer.ShowHand(true);
            DetermineWinner();
        }

        private async void SwitchTurn()
        {
            Player nextPlayer = CurrentTurn.CurrentPlayer is HumanPlayer ? ComputerPlayer : HumanPlayer;
            await PlayerTurnAsync(nextPlayer);

        }

        private Player GetOtherPlayer(Player currentPlayer)
        {
            return currentPlayer == HumanPlayer ? ComputerPlayer : HumanPlayer;
        }

        private void DetermineWinner()
        {
            int humanValue = HumanPlayer.CalculateHandValue();
            int computerValue = ComputerPlayer.CalculateHandValue();

            Player winner;
            if (humanValue > computerValue)
            {
                winner = HumanPlayer;
            }
            else if (computerValue > humanValue)
            {
                winner = ComputerPlayer;
            }
            else
            {
                int humanHighCard = HumanPlayer.GetHighestCardValue();
                int computerHighCard = ComputerPlayer.GetHighestCardValue();

                if (humanHighCard > computerHighCard)
                {
                    winner = HumanPlayer;
                }
                else if (computerHighCard > humanHighCard)
                {
                    winner = ComputerPlayer;
                }
                else
                {
                    // It's a tie
                    winner = null;
                }
            }

            EndRound(winner);
        }

        private async void EndRound(Player winner)
        {
            RaiseGameEvent($"Ending round. Winner: {(winner == null ? "Tie" : winner.PlayerName)}", GameState.EndingRound);
            UIController.StopTurnCountdown();
            if (winner == null)
            {
                UIController.ShowMessage("It's a tie! Play another round!", 5f);
            }
            else
            {
                winner.AdjustCoins(Pot);
                ScoreKeeper.AddToTotalRoundScores(winner, Pot);
                UIController.ShowMessage($"{winner.PlayerName} wins the round and {Pot} coins!", 6f);
                await Task.Delay(6000);
                UIController.UpdateRoundDisplay();
            }

            if (HumanPlayer.Coins <= 0 || ComputerPlayer.Coins <= 0)
            {
                await EndGame();
            }
            else
            {
                CheckForContinuation();
            }

            Pot = 0;
            UpdateGameState();
        }

        private async void CheckForContinuation()
        {
            RaiseGameEvent("Checking for game continuation", GameState.EndingRound);
            if (CurrentRound >= MaxRounds)
            {
                Player trailingPlayer = ScoreKeeper.HumanTotalWins < ScoreKeeper.ComputerTotalWins ? HumanPlayer : ComputerPlayer;
                Player leadingPlayer = GetOtherPlayer(trailingPlayer);

                if (trailingPlayer.Coins > leadingPlayer.Coins)
                {
                    UIController.OfferContinuation(10);
                    await Task.Delay(10000);
                }
                else
                {
                    await EndGame();
                }
            }
            else
            {
                await StartNewRoundAsync();
            }
        }

        public async Task ContinueGame(bool playerWantsToContinue)
        {
            if (playerWantsToContinue)
            {
                await StartNewRoundAsync();
            }
            else
            {
                await EndGame();
            }
        }

        private async Task EndGame()
        {
            Player winner;
            if (HumanPlayer.Coins <= 0)
            {
                winner = ComputerPlayer;
            }
            else if (ComputerPlayer.Coins <= 0)
            {
                winner = HumanPlayer;
            }
            else if (ScoreKeeper.HumanTotalWins != ScoreKeeper.ComputerTotalWins)
            {
                winner = ScoreKeeper.HumanTotalWins > ScoreKeeper.ComputerTotalWins ? HumanPlayer : ComputerPlayer;
            }
            else
            {
                winner = HumanPlayer.Coins > ComputerPlayer.Coins ? HumanPlayer : ComputerPlayer;
            }

            UIController.ShowMessage($"Game Over! {winner.PlayerName} wins the game!", 6f);

            RaiseGameEvent($"Game Over! {winner.PlayerName} wins the game!", GameState.GameOver);

            await Task.Delay(6000);
            UIController.OfferNewGame();
        }

        public void PurchaseCoins(Player player, int amount)
        {
            // This method would interface with the external service to handle coin purchases
            // For now, we'll just add the coins directly
            player.AdjustCoins(amount);
            UpdateGameState();
        }

        public void SetCurrentBet(int bet)
        {
            CurrentBet = bet;
        }
    }

    public enum GameState
    {
        Initializing,
        WaitingForPlayerAction,
        ProcessingAction,
        EndingRound,
        GameOver,
        StartNewGame,
        StartNewRound
    }
}

// ---

// File: ComputerPlayer.cs

using OcentraAI.LLMGames.Scriptable;
using OcentraAI.LLMGames.ThreeCardBrag.Manager;
using System.Linq;
using System.Threading.Tasks;
using UnityEngine;

namespace OcentraAI.LLMGames.ThreeCardBrag.Players
{
    public class ComputerPlayer : Player
    {
        private Card FloorCard => GameManager.Instance.DeckManager.FloorCard;

        public void MakeDecision(int currentBet)
        {
            // string aiInstruction = GameManager.Instance.AIHelper.GetAIInstructions();

            // todo send the hand and all prompt to LLM , use AIHelper to get instruction and send it to Chatgpt for now
            // Start the async method to simulate thinking for now
            SimulateThinkingAndMakeDecision();
        }

        private async void SimulateThinkingAndMakeDecision()
        {
            // Simulate thinking time
            float thinkingTime = Random.Range(1f, 10f); // Random thinking time between 1 and 3 seconds
            await Task.Delay((int)(thinkingTime * 1000));

            // Make the decision after the delay
            int handValue = CalculateHandValue();

            if (!HasSeenHand)
            {
                TakeAction(Random.value > 0.5f ? PlayerAction.PlayBlind : PlayerAction.SeeHand);
            }
            else if (handValue >= 35)
            {
                TakeAction(PlayerAction.Show);
            }
            else if (handValue >= 25)
            {
                TakeAction(Random.value > 0.5f ? PlayerAction.Call : PlayerAction.Raise);
            }
            else
            {
                if (Random.value > 0.3f)
                {
                    TakeAction(PlayerAction.DrawFromDeck);
                }
                else
                {
                    if (FloorCard != null)
                    {
                        int worstCardIndex = FindWorstCardIndex();
                        GameManager.Instance.DeckManager.SetSwapCard(Hand[worstCardIndex]);
                        TakeAction(PlayerAction.PickAndSwap);
                    }
                }
            }

            GameManager.Instance.UIController.SetComputerSeenHand(HasSeenHand);


            GameManager.Instance.UIController.ActionCompletionSource.SetResult(true);
        }

        private int FindWorstCardIndex()
        {
            return Hand.FindIndex(c => c.GetRankValue() == Hand.Min(card => card.GetRankValue()));
        }

        public override void SeeHand()
        {
            base.SeeHand();
            // Don't trigger UI update for computer's hand
        }

        public override void ShowHand(bool isRoundEnd = false)
        {
            base.ShowHand(isRoundEnd);
            GameManager.Instance.UIController.UpdateComputerHandDisplay(isRoundEnd);
        }
    }
}


// ---

// File: HumanPlayer.cs

using OcentraAI.LLMGames.ThreeCardBrag.Manager;

namespace OcentraAI.LLMGames.ThreeCardBrag.Players
{
    public class HumanPlayer : Player
    {


        public override void SeeHand()
        {
            base.SeeHand();
            GameManager.Instance.UIController.UpdateHumanPlayerHandDisplay();
        }

        public override void ShowHand(bool isRoundEnd=false)
        {
            base.ShowHand(isRoundEnd);
            GameManager.Instance.UIController.UpdateHumanPlayerHandDisplay(isRoundEnd);
        }
        
    }
}

// ---

// File: Player.cs

using OcentraAI.LLMGames.Scriptable;
using OcentraAI.LLMGames.Scriptable.ScriptableSingletons;
using OcentraAI.LLMGames.ThreeCardBrag.Manager;
using Sirenix.OdinInspector;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace OcentraAI.LLMGames.ThreeCardBrag.Players
{
    public class Player
    {
        private DeckManager DeckManager => GameManager.Instance.DeckManager;

        [ShowInInspector, ReadOnly]
        public string PlayerName { get; private set; }
        [ShowInInspector, ReadOnly]
        public List<Card> Hand { get; private set; } = new List<Card>();

        [ShowInInspector, ReadOnly]
        public int Coins { get; private set; }
        [ShowInInspector, ReadOnly]
        public bool HasSeenHand { get; private set; } = false;
        [ShowInInspector, ReadOnly]
        public bool HasBetOnBlind { get; private set; } = true;

        public event Action<PlayerAction> OnActionTaken;
        public event Action OnCoinsChanged;

        public void TakeAction(PlayerAction action)
        {
            GameManager.Instance.UIController.ShowMessage($"Player {PlayerName} Took Action {action}", 5f);
            OnActionTaken?.Invoke(action);
        }

        public virtual void SetName(string playerName)
        {
            PlayerName = playerName;
        }



        public virtual void SeeHand()
        {
            HasSeenHand = true;
            ShowHand();
        }

        public virtual void Bet()
        {
            AdjustCoins(-GameManager.Instance.CurrentBet);
        }

        public virtual void Raise()
        {
            AdjustCoins(-GameManager.Instance.CurrentBet);
        }

        public virtual void Fold()
        {
            Hand.Clear();
        }

        public virtual void DrawFromDeck()
        {
            DeckManager.SetFloorCard(DeckManager.DrawCard());
            GameManager.Instance.UIController.UpdateFloorCard();
        }

        public virtual void PickAndSwap()
        {
            Card floorCard = DeckManager.FloorCard;
            Card swapCard = DeckManager.SwapCard;

            if (floorCard != null && swapCard != null)
            {
                DeckManager.AddToFloorCardList(swapCard);

                int swapCardIndex = -1;
                for (int i = 0; i < Hand.Count; i++)
                {
                    if (Hand[i] == swapCard)
                    {
                        swapCardIndex = i;
                        break;
                    }
                }

                if (swapCardIndex >= 0)
                {
                    Hand[swapCardIndex] = floorCard;
                }
                else
                {
                    Debug.LogError($" no card matches swapCard {swapCard.Suit} of {swapCard.Rank} in hand");
                    return;
                }

                DeckManager.SetFloorCard(null);
                DeckManager.SetSwapCard(null);


                GameManager.Instance.UIController.UpdateGameState();
            }
        }




        public virtual void BetOnBlind()
        {
            AdjustCoins(-GameManager.Instance.CurrentBet);
            HasBetOnBlind = true;
        }

        public int CalculateHandValue()
        {
            int handValue = Hand.Sum(card => card.GetRankValue());
            var bonusRules = GameInfo.Instance.BonusRules;

            foreach (var rule in bonusRules)
            {
                if (rule.Evaluate(Hand))
                {
                    handValue += rule.BonusValue;
                }
            }

            return handValue;
        }

        public int GetHighestCardValue()
        {
            return Hand.Max(card => card.GetRankValue());
        }

        public virtual void ShowHand(bool isRoundEnd = false)
        {
            foreach (var card in Hand)
            {
               // Debug.Log($"{PlayerName}'s card: {card.Rank} of {card.Suit}");
            }
            //Debug.Log($"{PlayerName}'s hand value: {CalculateHandValue()}");
        }

        public void ResetForNewRound()
        {
            Hand.Clear();
            HasSeenHand = false;
            HasBetOnBlind = true;
        }

        public void AdjustCoins(int amount)
        {
            Coins += amount;
            OnCoinsChanged?.Invoke();
        }
    }
}


// ---

// File: PlayerAction.cs

namespace OcentraAI.LLMGames.ThreeCardBrag.Players
{
    public enum PlayerAction
    {
        SeeHand,
        PlayBlind,
        Bet,
        Call,
        Raise,
        Fold,
        DrawFromDeck,
        PickAndSwap,
        Show
    }
}

// ---

// File: PlayerTimer.cs

using OcentraAI.LLMGames.Extensions;
using OcentraAI.LLMGames.ThreeCardBrag.Manager;
using Sirenix.OdinInspector;
using System.Threading.Tasks;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace OcentraAI.LLMGames.ThreeCardBrag.Players
{
    public class PlayerTimer : MonoBehaviour
    {
        [Required, ShowInInspector]
        private TextMeshProUGUI TurnCountdownText { get; set; }

        [Required, ShowInInspector]
        private Image CircleImage { get; set; }

        [Required, ShowInInspector]
        private Image BackgroundImage { get; set; }

        [Required, ShowInInspector]
        private Image Image { get; set; }

        private Player Player { get; set; }
        private float Duration => GameManager.Instance.TurnDuration;
        private float RemainingTime { get; set; }
        private TaskCompletionSource<bool> TimerCompletionSource { get; set; }

        private void OnValidate()
        {
            Init();
        }

        void Start()
        {
            Init();
        }

        private void Init()
        {
            Image = GetComponent<Image>();
            TurnCountdownText = transform.FindChildRecursively<TextMeshProUGUI>(nameof(TurnCountdownText));
            CircleImage = transform.FindChildRecursively<Image>(nameof(CircleImage));
            BackgroundImage = transform.FindChildRecursively<Image>(nameof(BackgroundImage));
        }

        public void SetPlayer(Player player)
        {
            Player = player;
        }

        public async Task StartTimer()
        {
            Show(true, nameof(StartTimer));
            RemainingTime = Duration;
            TimerCompletionSource = new TaskCompletionSource<bool>();

            while (RemainingTime > 0)
            {
                UpdateDisplay();
                await Task.Yield();
                RemainingTime = Mathf.Max(0, RemainingTime - Time.deltaTime);
            }

            UpdateDisplay();
            TimerCompletionSource.TrySetResult(true);
        }

        public void StopTimer()
        {
            Show(false, nameof(StopTimer));
            TimerCompletionSource?.TrySetResult(false);
            ResetTimer();
        }

        public Task<bool> WaitForCompletion()
        {
            return TimerCompletionSource?.Task ?? Task.FromResult(true);
        }

        private void UpdateDisplay()
        {
            if (TurnCountdownText != null) TurnCountdownText.text = $"{RemainingTime:F1}";
            if (CircleImage != null) CircleImage.fillAmount = RemainingTime / Duration;
        }

        private void ResetTimer()
        {
            RemainingTime = Duration;
            UpdateDisplay();
        }

        public void Show(bool show, string fromMethod)
        {
            if (TurnCountdownText != null) TurnCountdownText.enabled = show;
            if (CircleImage != null) CircleImage.enabled = show;
            if (BackgroundImage != null) BackgroundImage.enabled = show;
            if (Image != null) Image.enabled = show;
        }
    }
}

// ---

// File: TurnInfo.cs

using System.Threading.Tasks;

namespace OcentraAI.LLMGames.ThreeCardBrag.Players
{
    [System.Serializable]
    public class TurnInfo
    {
        public Player CurrentPlayer;
        public float ElapsedTime;
        public TaskCompletionSource<bool> TurnCompletionSource;
        public TurnInfo(Player currentPlayer)
        {
            CurrentPlayer = currentPlayer;
            ElapsedTime = 0f;
            TurnCompletionSource = new TaskCompletionSource<bool>();
        }
    }
}

// ---

// File: RoundScore.cs

using OcentraAI.LLMGames.ThreeCardBrag.Players;

namespace OcentraAI.LLMGames.ThreeCardBrag.Scores
{
    [System.Serializable]
    public class RoundScore
    {
        public Player Winner;
        public int Pot;
    }
}

// ---

// File: ScoreKeeper.cs

using OcentraAI.LLMGames.ThreeCardBrag.Players;
using System.Collections.Generic;

namespace OcentraAI.LLMGames.ThreeCardBrag.Scores
{
    public class ScoreKeeper 
    {

        public List<RoundScore> RoundScores = new List<RoundScore>();
        public int HumanTotalWins = 0;
        public int ComputerTotalWins = 0;
        public RoundScore RoundScore = new RoundScore();




        public void AddToTotalRoundScores(Player player, int pot)
        {
            RoundScore.Winner = player;
            RoundScore.Pot = pot;
            RoundScores.Add(RoundScore);
            switch (player)
            {
                case HumanPlayer:
                    HumanTotalWins++;
                    break;
                case ComputerPlayer:
                    ComputerTotalWins++;
                    break;
            }

            RoundScore = new RoundScore();
        }

        public void ResetScores()
        {
            RoundScores.Clear();
            HumanTotalWins = 0;
            ComputerTotalWins = 0;
        }
    }
}

// ---

// File: BragSelectable.cs

using OcentraAI.LLMGames.Screens;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using Sirenix.OdinInspector;

namespace OcentraAI.LLMGames.ThreeCardBrag.UI

{
    public class BragSelectable : Selectable, ISubmitHandler, ICancelHandler, IPointerClickHandler
    {
        public Toggle Toggle;
        public Button Button;
        public Slider Slider;
        public float SliderSensitivity = 1f;
        public bool SelectOnPointerEnter = false;
        public bool SendButtonClickToSubmit = false;

        public UnityEvent OnBragSelected;
        public UnityEvent OnBragDeselected;
        public UnityEvent OnBragSubmit;
        public UnityEvent OnBragCancel;

        [ReadOnly]
        public UIScreen ParentScreen;

        protected override void Awake()
        {
            base.Awake();
            if (Toggle != null)
            {
                Toggle.interactable = false;
            }
            if (Button != null)
            {
                Button.interactable = false;
            }
        }

        public override void OnSelect(BaseEventData eventData)
        {
            base.OnSelect(eventData);
            if (Toggle != null)
            {
                Toggle.isOn = true;
            }
            OnBragSelected?.Invoke();
            if (ParentScreen != null)
            {
                ParentScreen.PlaySelectionSound();
            }
        }

        public override void OnDeselect(BaseEventData eventData)
        {
            base.OnDeselect(eventData);
            if (Toggle != null)
            {
                Toggle.isOn = false;
            }
            OnBragDeselected?.Invoke();
        }

        public override void OnMove(AxisEventData eventData)
        {
            base.OnMove(eventData);
            if (ParentScreen != null && !ParentScreen.Interactable)
                return;

            switch (eventData.moveDir)
            {
                case MoveDirection.Left:
                case MoveDirection.Right:
                    MoveSlider(eventData.moveVector.x);
                    break;
            }

            if (ParentScreen != null)
            {
                ParentScreen.PlayNavigationSound();
            }
        }

        private void MoveSlider(float value)
        {
            if (Slider == null)
                return;
            
            Slider.value += value * SliderSensitivity * Time.deltaTime;
        }

        public void OnSubmit(BaseEventData eventData)
        {
            if (ParentScreen != null && !ParentScreen.Interactable)
                return;

            if (Button != null)
            {
                Button.onClick.Invoke();
            }
            OnBragSubmit?.Invoke();
            if (ParentScreen != null)
            {
                ParentScreen.PlaySelectionSound();
            }
        }

        public void OnCancel(BaseEventData eventData)
        {
            if (ParentScreen != null && !ParentScreen.Interactable)
                return;

            OnBragCancel?.Invoke();
            if (ParentScreen != null)
            {
                ParentScreen.PlayBackGroundSound();
            }
        }

        public void OnPointerClick(PointerEventData eventData)
        {
            if (ParentScreen != null && !ParentScreen.Interactable)
                return;

            if (SendButtonClickToSubmit)
            {
                if(Button != null)
                    Button.onClick.Invoke();
                OnBragSubmit?.Invoke();
                if (ParentScreen != null)
                {
                    ParentScreen.PlaySelectionSound();
                }
            }
        }

        public override void OnPointerEnter(PointerEventData eventData)
        {
            base.OnPointerEnter(eventData);
            if (SelectOnPointerEnter)
            {
                EventSystem.current.SetSelectedGameObject(this.gameObject);
            }
        }
    }
}






// ---

// File: CardView.cs

using OcentraAI.LLMGames.Scriptable;
using OcentraAI.LLMGames.Scriptable.ScriptableSingletons;
using Sirenix.OdinInspector;
using UnityEngine;
using UnityEngine.UI;

namespace OcentraAI.LLMGames.ThreeCardBrag.UI
{
    public class CardView : MonoBehaviour
    {
        [ShowInInspector] 
        public Image CardImage { get; private set; }
        
        [ShowInInspector]
        public Card Card { get; private set; }
        
        [ShowInInspector]
        private Transform Parent { get; set; }
        


        void OnValidate()
        {
            Init();

        }
        void Start()
        {
            Init();
        }

        private void Init()
        {
            if (CardImage == null )
            {
                CardImage = GetComponent<Image>();
            }

            Parent = transform.parent;


            UpdateCardView();
        }

        public void SetCard(Card newCard)
        {
            Card = newCard;
        }

        public void ShowBackside()
        {
            CardImage.sprite = Deck.Instance.BackCard.Sprite;
        }

        public void UpdateCardView()
        {

            if (Card != null && Card.Sprite != null )
            {
                CardImage.sprite = Card.Sprite;
            }
            else
            {
                ShowBackside();
            }
        }

        public void SetActive(bool value)
        {
            
            gameObject.SetActive(value);
            Parent.gameObject.SetActive(value);
        }



        public void ResetCardView()
        {
            Card = null;
            ShowBackside();
        }
    }
}

// ---

// File: Draggable.cs

using OcentraAI.LLMGames.ThreeCardBrag.UI.Controllers;
using Sirenix.OdinInspector;
using UnityEngine;
using UnityEngine.EventSystems;

namespace OcentraAI.LLMGames.ThreeCardBrag.UI
{
    public class Draggable : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler
    {
        [ShowInInspector, Required]

        private CanvasGroup CanvasGroup { get; set; }

        [ShowInInspector, Required]

        private Vector2 OriginalPosition { get; set; }

        [ShowInInspector, Required]
        private RectTransform RectTransform { get; set; }

        [ShowInInspector, Required]
        private UIController UIController { get; set; }


        void OnValidate()
        {
            Init();
        }

        void Start()
        {
            Init();
        }

        private void Init()
        {
            CanvasGroup = FindObjectOfType<CanvasGroup>();
            RectTransform = GetComponent<RectTransform>();
            UIController = FindObjectOfType<UIController>();

        }


        public async void OnBeginDrag(PointerEventData eventData)
        {
            OriginalPosition = RectTransform.anchoredPosition;
            CanvasGroup.blocksRaycasts = false;
            await UIController.OnPickFromFloor();
        }

        public void OnDrag(PointerEventData eventData)
        {
            RectTransform.anchoredPosition += eventData.delta / RectTransform.localScale;
        }

        public void OnEndDrag(PointerEventData eventData)
        {
            CanvasGroup.blocksRaycasts = true;
            if (eventData.pointerEnter == null || eventData.pointerEnter.GetComponent<DropZone>() == null)
            {
                RectTransform.anchoredPosition = OriginalPosition;
            }

            //  UIController.OnEndPickFromFloor();
        }
    }
}

// ---

// File: DropZone.cs

using OcentraAI.LLMGames.ThreeCardBrag.UI.Controllers;
using Sirenix.OdinInspector;
using UnityEngine;
using UnityEngine.EventSystems;

namespace OcentraAI.LLMGames.ThreeCardBrag.UI
{
    public class DropZone : MonoBehaviour, IDropHandler
    {
        [ShowInInspector, Required]
        private CardView CardView { get; set; }

        [ShowInInspector, Required]
        private UIController UIController { get; set; }
        void OnValidate()
        {
            Init();
        }

        void Start()
        {
            Init();
        }

        private void Init()
        {
            CardView = GetComponent<CardView>();
            UIController = FindObjectOfType<UIController>();

        }

        public void OnDrop(PointerEventData eventData)
        {
            CardView cardView = eventData.pointerDrag.GetComponent<CardView>();
            if (cardView != null)
            {
                UIController.OnDiscardCardSet(cardView);
            }
        }
    }
}

// ---

// File: LeftPanelController.cs

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using Sirenix.OdinInspector;
using System.Collections;
using OcentraAI.LLMGames.Extensions;
using OcentraAI.LLMGames.Scriptable;

namespace OcentraAI.LLMGames.ThreeCardBrag.UI.Controllers
{
    public class LeftPanelController : MonoBehaviour
    {
        public RectTransform Panel;
        [Required]
        public RectTransform Middle;
        [Required]
        public LayoutElement MiddleLayoutElement;
        [Required]
        public Transform FloorCardsHolder;
        [Required]
        public GridLayoutGroup FloorCardsGrid;
        [Required]
        public Button ShowAllFloorCards;
        public List<GameObject> FloorCards = new List<GameObject>();
        public float MinHeight = 700;
        public float MaxHeight = 70000;
        public bool IsExpanded = false;
        [Required]
        public GameObject CardViewPrefab;

        void Start()
        {
            Init();
            ShowAllFloorCards.onClick.AddListener(ToggleExpand);
        }

        void OnValidate()
        {
            Init();
        }

        private void Init()
        {
            IsExpanded = false;
            Panel = GetComponent<RectTransform>();
            Middle = transform.FindChildRecursively<RectTransform>(nameof(Middle));
            MiddleLayoutElement = Middle.GetComponent<LayoutElement>();
            FloorCardsHolder = transform.FindChildRecursively<Transform>(nameof(FloorCardsHolder));
            FloorCardsGrid = FloorCardsHolder.GetComponent<GridLayoutGroup>();
            ShowAllFloorCards = transform.FindChildRecursively<Button>(nameof(ShowAllFloorCards));

            CardViewPrefab = Resources.Load<GameObject>($"Prefabs/{nameof(CardViewPrefab)}");
            CollapsePanel();
        }

        public void AddCard(Card card)
        {
            if (CardViewPrefab != null && FloorCardsHolder != null)
            {
                GameObject newCardViewObject = Instantiate(CardViewPrefab, FloorCardsHolder);
                CardView newCardView = newCardViewObject.GetComponentInChildren<CardView>();

                if (newCardView != null)
                {
                    newCardView.SetCard(card);
                    newCardView.SetActive(true);
                    newCardView.UpdateCardView();

                    for (int i = 0; i < FloorCards.Count; i++)
                    {
                        FloorCards[i].transform.SetSiblingIndex(i);
                    }

                    if (!IsExpanded && FloorCards.Count > 8)
                    {
                        for (int i = 8; i < FloorCards.Count; i++)
                        {
                            FloorCards[i].SetActive(false);
                        }
                    }
                }

                FloorCards.Insert(0, newCardViewObject);

            }
            else
            {
                Debug.LogError($" error adding cards CardViewPrefab null ? {CardViewPrefab == null} FloorCardsHolder null ? {FloorCardsHolder == null}");
            }

        }

        [Button]
        void ToggleExpand()
        {
            if (IsExpanded)
            {
                CollapsePanel();
            }
            else
            {
                ShowAllFloorCards.gameObject.SetActive(false);

                ExpandPanel();

                StartCoroutine(CollapseAfterDelay(15f));
            }

            IsExpanded = !IsExpanded;
        }

        IEnumerator CollapseAfterDelay(float delay)
        {
            yield return new WaitForSeconds(delay);

            CollapsePanel();

            ShowAllFloorCards.gameObject.SetActive(true);

            IsExpanded = false;
        }

        void ExpandPanel()
        {
            MiddleLayoutElement.preferredHeight = MaxHeight;
            FloorCardsGrid.cellSize = new Vector2(75, 125);

            foreach (GameObject go in FloorCards)
            {
                CardView cardView = go.GetComponent<CardView>();
                if (cardView != null)
                {
                    cardView.SetActive(true);

                }
            }
        }

        void CollapsePanel()
        {
            MiddleLayoutElement.preferredHeight = MinHeight;
            FloorCardsGrid.cellSize = new Vector2(142, 227);

            if (FloorCards.Count > 8)
            {
                for (int i = 8; i < FloorCards.Count; i++)
                {
                    GameObject floorCard = FloorCards[i];
                    CardView cardView = floorCard.GetComponentInChildren<CardView>();
                    cardView.SetActive(false);
                }
            }
        }

        public void ResetView()
        {
            foreach (Transform child in FloorCardsHolder)
            {
                Destroy(child.gameObject);
            }

            FloorCards.Clear();
        }
    }
}


// ---

// File: UIController.cs

using OcentraAI.LLMGames.Extensions;
using OcentraAI.LLMGames.Scriptable;
using OcentraAI.LLMGames.ThreeCardBrag.Manager;
using OcentraAI.LLMGames.ThreeCardBrag.Players;
using Sirenix.OdinInspector;
using System.Threading.Tasks;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

namespace OcentraAI.LLMGames.ThreeCardBrag.UI.Controllers
{
    public class UIController : MonoBehaviour
    {
        [ShowInInspector]
        private DeckManager DeckManager { get; set; }

        [Required, ShowInInspector]
        private Button ShowPlayerHand { get; set; }
        [Required, ShowInInspector]
        private Button PlayBlind { get; set; }
        [Required, ShowInInspector]
        private Button RaiseBet { get; set; }

        [Required, ShowInInspector]
        private Button Fold { get; set; }

        [Required, ShowInInspector]
        private Button DrawFromDeck { get; set; }

        [Required, ShowInInspector]
        private Button PickFromFloor { get; set; }

        [Required, ShowInInspector]
        private Button ShowCall { get; set; }



        [Required, ShowInInspector]
        private Button ContinueRound { get; set; }

        [Required, ShowInInspector]
        private Button NewGame { get; set; }
        [Required, ShowInInspector]
        private Button PurchaseCoins { get; set; }

        [Required, ShowInInspector]
        private Transform ComputerHand { get; set; }

        [Required, ShowInInspector]
        private Transform MessageHolder { get; set; }

        [Required, ShowInInspector]
        private TMP_InputField RaiseAmount { get; set; }

        [Required, ShowInInspector]
        private TextMeshProUGUI Message { get; set; }

        [Required, ShowInInspector]
        private TextMeshProUGUI HumanPlayersCoins { get; set; }

        [Required, ShowInInspector]
        private TextMeshProUGUI ComputerPlayerCoins { get; set; }

        [Required, ShowInInspector]
        private TextMeshProUGUI HumanPlayersWins { get; set; }

        [Required, ShowInInspector]
        private TextMeshProUGUI ComputerPlayerWins { get; set; }

        [Required, ShowInInspector]
        private TextMeshProUGUI Pot { get; set; }

        [Required, ShowInInspector]
        private TextMeshProUGUI CurrentBet { get; set; }

        [Required, ShowInInspector]
        private TextMeshProUGUI ComputerPlayingBlind { get; set; }

        [Required, ShowInInspector]
        private PlayerTimer HumanPlayerTimer { get; set; }

        [Required, ShowInInspector]
        private PlayerTimer ComputerPlayerTimer { get; set; }

        [Required, ShowInInspector]
        public PlayerTimer CurrentPlayerTimer { get; set; }

        [Required, ShowInInspector]
        private CardView[] HumanPlayerCardViews { get; set; }

        [Required, ShowInInspector]
        private CardView FloorCardView { get; set; }

        [Required, ShowInInspector]
        private CardView[] ComputerPlayerCardViews { get; set; }


        public TaskCompletionSource<bool> ActionCompletionSource { get; private set; }

        [Required, ShowInInspector]
        public LeftPanelController LeftPanelController { get; set; }

        void OnValidate()
        {
            Init();
        }

        private void Init()
        {
            if (GameManager.Instance != null)
            {
                DeckManager = GameManager.Instance.DeckManager;
            }

            ComputerHand = transform.FindChildRecursively<Transform>(nameof(ComputerHand));
            MessageHolder = transform.FindChildRecursively<Transform>(nameof(MessageHolder));

            ShowPlayerHand = transform.FindChildRecursively<Button>(nameof(ShowPlayerHand));
            PlayBlind = transform.FindChildRecursively<Button>(nameof(PlayBlind));
            RaiseBet = transform.FindChildRecursively<Button>(nameof(RaiseBet));
            Fold = transform.FindChildRecursively<Button>(nameof(Fold));
            DrawFromDeck = transform.FindChildRecursively<Button>(nameof(DrawFromDeck));
            PickFromFloor = transform.FindChildRecursively<Button>(nameof(PickFromFloor));
            ShowCall = transform.FindChildRecursively<Button>(nameof(ShowCall));
            ContinueRound = transform.FindChildRecursively<Button>(nameof(ContinueRound));
            NewGame = transform.FindChildRecursively<Button>(nameof(NewGame));
            PurchaseCoins = transform.FindChildRecursively<Button>(nameof(PurchaseCoins));

            HumanPlayerCardViews = ShowPlayerHand.GetComponentsInChildren<CardView>();
            ComputerPlayerCardViews = ComputerHand.GetComponentsInChildren<CardView>();

            FloorCardView = transform.FindChildRecursively<CardView>(nameof(FloorCardView));

            Message = transform.FindChildRecursively<TextMeshProUGUI>(nameof(Message));
            HumanPlayersCoins = transform.FindChildRecursively<TextMeshProUGUI>(nameof(HumanPlayersCoins));
            ComputerPlayerCoins = transform.FindChildRecursively<TextMeshProUGUI>(nameof(ComputerPlayerCoins));
            Pot = transform.FindChildRecursively<TextMeshProUGUI>(nameof(Pot));
            CurrentBet = transform.FindChildRecursively<TextMeshProUGUI>(nameof(CurrentBet));
            ComputerPlayingBlind = transform.FindChildRecursively<TextMeshProUGUI>(nameof(ComputerPlayingBlind));

            ComputerPlayerWins = transform.FindChildRecursively<TextMeshProUGUI>(nameof(ComputerPlayerWins));
            HumanPlayersWins = transform.FindChildRecursively<TextMeshProUGUI>(nameof(HumanPlayersWins));

            HumanPlayerTimer = transform.parent.FindChildRecursively<PlayerTimer>(nameof(HumanPlayerTimer));
            ComputerPlayerTimer = transform.parent.FindChildRecursively<PlayerTimer>(nameof(ComputerPlayerTimer));

            RaiseAmount = transform.FindChildRecursively<TMP_InputField>(nameof(RaiseAmount));
            if (NewGame != null) NewGame.gameObject.SetActive(false);
            if (ContinueRound != null) ContinueRound.gameObject.SetActive(false);
            if (MessageHolder != null) MessageHolder.gameObject.SetActive(false);



            LeftPanelController = FindObjectOfType<LeftPanelController>();
        }

        private void Start()
        {
            Init();

            if (ShowPlayerHand != null) ShowPlayerHand.onClick.AddListener(async () => await OnShowPlayerHand());
            if (PlayBlind != null) PlayBlind.onClick.AddListener(async () => await OnPlayBlind());
            if (RaiseBet != null) RaiseBet.onClick.AddListener(async () => await OnRaiseBet());
            if (Fold != null) Fold.onClick.AddListener(async () => await OnFold());
            if (DrawFromDeck != null) DrawFromDeck.onClick.AddListener(async () => await OnDrawFromDeck());
            if (ShowCall != null) ShowCall.onClick.AddListener(async () => await OnShowCall());



            if (ContinueRound != null) ContinueRound.onClick.AddListener(async () => await GameManager.Instance.ContinueGame(true));
            if (NewGame != null) NewGame.onClick.AddListener(async () => await GameManager.Instance.StartNewGameAsync());
            if (PurchaseCoins != null)
            {
                PurchaseCoins.onClick.AddListener(() => GameManager.Instance.PurchaseCoins(GameManager.Instance.HumanPlayer, 1000));
            }

        }

        public Task InitializePlayers()
        {
            HumanPlayerTimer.SetPlayer(GameManager.Instance.HumanPlayer);
            HumanPlayerTimer.Show(false, nameof(Start));

            ComputerPlayerTimer.SetPlayer(GameManager.Instance.ComputerPlayer);
            ComputerPlayerTimer.Show(false, nameof(Start));

            return Task.CompletedTask;
        }

        private async Task OnShowCall()
        {
            await TakeActionAsync(PlayerAction.Show);
        }

        private async Task OnDrawFromDeck()
        {

            await TakeActionAsync(PlayerAction.DrawFromDeck);
        }

        private async Task OnFold()
        {
            await TakeActionAsync(PlayerAction.Fold);
        }

        private async Task OnPlayBlind()
        {
            await TakeActionAsync(PlayerAction.PlayBlind);
        }

        public void OnDiscardCardSet(CardView cardView)
        {
            if (DeckManager != null)
            {
                Card card = cardView.Card;

                DeckManager.SetSwapCard(card);
            }
        }

        public async Task OnPickFromFloor()
        {
            ShowMessage($"Drop the Card to Hand Card to discard, else Draw new card ", 5f);
            await WaitForSwapCardIndexAsync();
        }
        private async Task OnShowPlayerHand()
        {
            ShowPlayerHand.enabled = false;
            await TakeActionAsync(PlayerAction.SeeHand);
        }


        private async Task OnRaiseBet()
        {
            if (string.IsNullOrEmpty(RaiseAmount.text))
            {
                ShowMessage($" Please Set RaiseAmount ! Needs to be higher than CurrentBet {GameManager.Instance.CurrentBet}", 5f);
                return;
            }

            if (int.TryParse(RaiseAmount.text, out int raiseAmount) && raiseAmount > GameManager.Instance.CurrentBet)
            {
                GameManager.Instance.SetCurrentBet(raiseAmount);
                await TakeActionAsync(PlayerAction.Raise);
            }
            else
            {
                ShowMessage($" RaiseAmount {raiseAmount} Needs to be higher than CurrentBet {GameManager.Instance.CurrentBet}", 5f);
            }
        }
        private async Task WaitForSwapCardIndexAsync()
        {
            if (DeckManager != null)
            {
                await Task.Run(async () =>
                {
                    while (DeckManager.SwapCard == null)
                    {
                        await Task.Delay(100); // Check every 100ms
                    }
                });
                await TakeActionAsync(PlayerAction.PickAndSwap);
            }
            else
            {
                Debug.LogError($"DeckManager is null!");
            }
        }
        public void SetComputerSeenHand(bool hasSeenHand)
        {
            string message = GameManager.Instance.BlindMultiplier > 1 ? $" Playing Blind {GameManager.Instance.BlindMultiplier}" : $" Playing Blind ";
            ComputerPlayingBlind.text = hasSeenHand ? "" : message;
        }



        private async Task TakeActionAsync(PlayerAction action)
        {
            await GameManager.Instance.HandlePlayerAction(action);
            ActionCompletionSource?.TrySetResult(true);
        }

        public void UpdateGameState(bool isNewRound = false)
        {
            UpdateCoinsDisplay();
            UpdatePotDisplay();
            UpdateCurrentBetDisplay();
            UpdateHumanPlayerHandDisplay();
            UpdateFloorCard();
            if (isNewRound)
            {
                ResetAllCardViews();
            }
        }

        private void ResetAllCardViews()
        {
            foreach (CardView cardView in HumanPlayerCardViews)
            {
                cardView.ResetCardView();
            }

            foreach (CardView cardView in ComputerPlayerCardViews)
            {
                cardView.ResetCardView();
            }

            LeftPanelController.ResetView();
        }

        public void EnablePlayerActions()
        {
            bool humanPlayerHasSeenHand = GameManager.Instance.HumanPlayer.HasSeenHand;
            bool isCurrentPlayerHuman = GameManager.Instance.CurrentTurn.CurrentPlayer == GameManager.Instance.HumanPlayer;

            if (PlayBlind != null) PlayBlind.gameObject.SetActive(!humanPlayerHasSeenHand);
            if (RaiseBet != null) RaiseBet.interactable = isCurrentPlayerHuman;
            if (Fold != null) Fold.interactable = isCurrentPlayerHuman;
            if (DrawFromDeck != null)
            {
                DrawFromDeck.interactable = humanPlayerHasSeenHand && isCurrentPlayerHuman;
            }

            //if (PickFromFloor != null) PickFromFloor.interactable = humanPlayerHasSeenHand && DeckManager.FloorCard != null;
            if (ShowCall != null) ShowCall.interactable = isCurrentPlayerHuman;


        }

        public void UpdateCoinsDisplay()
        {
            if (HumanPlayersCoins != null) HumanPlayersCoins.text = $"{GameManager.Instance.HumanPlayer.Coins}";
            if (ComputerPlayerCoins != null) ComputerPlayerCoins.text = $"{GameManager.Instance.ComputerPlayer.Coins}";
        }

        public void UpdatePotDisplay()
        {
            if (Pot != null) Pot.text = $"{GameManager.Instance.Pot}";
        }

        public void UpdateCurrentBetDisplay()
        {
            if (CurrentBet != null) CurrentBet.text = $"Current Bet: {GameManager.Instance.CurrentBet} ";
        }

        public void UpdateRoundDisplay()
        {
            ComputerPlayerWins.text = $"{GameManager.Instance.ScoreKeeper.ComputerTotalWins}";
            HumanPlayersWins.text = $"{GameManager.Instance.ScoreKeeper.HumanTotalWins}";
        }

        public void UpdateFloorCard()
        {
            if (FloorCardView != null)
            {
                if (DeckManager != null)
                {
                    FloorCardView.SetCard(DeckManager.FloorCard);

                    FloorCardView.UpdateCardView();
                    bool value = FloorCardView.Card != null;
                    FloorCardView.SetActive(value);
                }
                else
                {

                    FloorCardView.SetActive(false);
                }

            }
        }

        public void UpdateFloorCards(Card card)
        {
            LeftPanelController.AddCard(card);
        }

        public async void ShowMessage(string message, float delay = 5f)
        {
            if (MessageHolder != null)
            {
                MessageHolder.gameObject.SetActive(true);
                if (Message != null)
                {
                    Message.text = message;
                }

                await HideMessageAfterDelay(delay);

            }
        }

        private async Task HideMessageAfterDelay(float delay)
        {
            await Utility.Delay(delay);

            if (MessageHolder != null)
            {
                MessageHolder.gameObject.SetActive(false);
            }
        }

        public void OfferContinuation(float delay)
        {
            ShowMessage($" Do you Want to ContinueRound playing One More Round?", delay);
            if (ContinueRound != null) ContinueRound.gameObject.SetActive(true);
        }

        public void OfferNewGame()
        {
            ShowMessage($"Do you want to Play New Round ?", 15f);

            if (NewGame != null) NewGame.gameObject.SetActive(true);
        }

        public async void StartTurnCountdown()
        {
            // Debug.Log($"Starting countdown for {GameManager.Instance.CurrentTurn.CurrentPlayer.PlayerName} with duration {GameManager.Instance.TurnDuration}");
            ActionCompletionSource = new TaskCompletionSource<bool>();
            if (GameManager.Instance.CurrentTurn.CurrentPlayer is HumanPlayer)
            {
                CurrentPlayerTimer = HumanPlayerTimer;
                await HumanPlayerTimer.StartTimer();

            }
            else if (GameManager.Instance.CurrentTurn.CurrentPlayer is ComputerPlayer)

            {
                CurrentPlayerTimer = CurrentPlayerTimer;
                await ComputerPlayerTimer.StartTimer();

            }
        }

        public void StopTurnCountdown()
        {
            HumanPlayerTimer.Show(false, nameof(StopTurnCountdown));
            ComputerPlayerTimer.Show(false, nameof(StopTurnCountdown));
        }

        public void UpdateHumanPlayerHandDisplay(bool isRoundEnd = false)
        {
            if (GameManager.Instance.HumanPlayer.HasSeenHand || isRoundEnd)
            {
                for (int i = 0; i < GameManager.Instance.HumanPlayer.Hand.Count; i++)
                {
                    HumanPlayerCardViews[i].SetCard(GameManager.Instance.HumanPlayer.Hand[i]);
                    HumanPlayerCardViews[i].UpdateCardView();
                }

            }


        }

        public Task WaitForActionAsync()
        {
            ActionCompletionSource = new TaskCompletionSource<bool>();
            return ActionCompletionSource.Task;
        }

        public void ActivateDiscardCard(bool activate)
        {
            //Discard.ForEach(button =>
            //{
            //    button.enabled = true;
            //    button.interactable = activate;
            //});

        }

        public void UpdateComputerHandDisplay(bool isRoundEnd = false)
        {
            for (int i = 0; i < GameManager.Instance.ComputerPlayer.Hand.Count; i++)
            {
                ComputerPlayerCardViews[i].SetCard(GameManager.Instance.ComputerPlayer.Hand[i]);
            }

            if (isRoundEnd)
            {
                foreach (CardView cardView in ComputerPlayerCardViews)
                {
                    cardView.UpdateCardView();
                }
            }
            else
            {
                foreach (CardView cardView in ComputerPlayerCardViews)
                {
                    cardView.ShowBackside();
                }
            }
        }
    }
}

// ---

